<element elementid="099" elementType="InitialCode">
  <cleancode>
let dangerScores = null;
let graph = null;

function isBombBlockedAtPos(col, row, color) {
  // filter Tanks array
  const temp = Tanks.filter( t => t.color != color &amp;&amp; t.c == col &amp;&amp; t.r == row);
  const result = temp.length > 0 || Maze[row][col] == 'R' || Maze[row][col] == 'T';
  return result;
}

function getDangerScores() {
  const scores = createNewGraph();
  const myColor = MyTank.color;
  
  for (let i = 0; i &lt; Tanks.length; i += 1) {
    const t = Tanks[i];
    if (t.tankID == MyID || t.color == myColor) continue;
    const dscore = 1 + t.specialPower.damage;
    
    // tank facing upward
    if (t.dir == 'U') {
      for (let j = t.r - 1; j >= 0; j -= 1) {
        scores[j][t.c] += dscore;
        if (isBombBlockedAtPos(t.c, j, t.color)) break;
      }
    } else if (t.dir == 'D') { // facing downward
      for (let j = t.r + 1; j &lt; scores.length; j += 1) {
        scores[j][t.c] += dscore;
        if (isBombBlockedAtPos(t.c, j, t.color)) break;
      }
    } else if (t.dir === 'L') { // facing to the left
      for (let j = t.c - 1; j >= 0; j -= 1) {
        scores[t.r][j] += dscore;
        if (isBombBlockedAtPos(j, t.r, t.color)) break;
      }
    } else if (t.dir === 'R') { // facing to the right
      for (let j = t.c + 1; j &lt; scores[t.r].length; j += 1) {
        scores[t.r][j] += dscore;
        if (isBombBlockedAtPos(j, t.r, t.color)) break;
      }
    }
  }
  return scores;
}

function attackTank(target) {
  if (!target) return "";

  if (MyTank.r == target.r &amp;&amp; !isShellBlocked(MyTank, target)) {
    if (MyTank.c &lt; target.c &amp;&amp; MyTank.dir != "R") {
      return "R";
    } else if (MyTank.c > target.c &amp;&amp; MyTank.dir != "L") {
      return "L";
    } else {
      return "S";
    }
  } else if (MyTank.c == target.c &amp;&amp; !isShellBlocked(MyTank, target)) {
    if (MyTank.r &lt; target.r &amp;&amp; MyTank.dir != "D") {
      return "D";
    } else if (MyTank.r > target.r &amp;&amp; MyTank.dir != "U") {
      return "U";
    } else {
      return "S";
    }
  }

  const path = getShortestPathCmd(graph, MyTank, target);
  if (path.length > 0) return path[0];
  return '';
}

function attackWhiteTank() {
  const whiteTanks = Tanks.filter(tank => tank.color == 'white' &amp;&amp; 
  (MyTank.r != tank.r || MyTank.c != tank.c));
  const target = getClosestItem(whiteTanks);
  return attackTank(target);
}      

function createGraph() {
  // create a new Set to hold blocking tile types
  const blockingTileTypes = ['R', 'M', 'T'];
  // create a new graph
  const graph = createNewGraph();

  // set values of graph, 1 = pass and 0 = blockage
  for (let i = 0; i &lt; graph.length; i += 1) {
    for (let j = 0; j &lt; graph[i].length; j += 1) {
      // tile type
      const tile = Maze[i][j];
      // check if it is a blockage
      if (blockingTileTypes.includes(tile)) graph[i][j] = 0;
      else graph[i][j] = 1 + dangerScores[i][j];
    }
  }
  return graph;
}

function getClosestItem(items) {
  // initialize variables to hold shortest distance and target
  let shortDis = -1;
  let target = null;
  const oppoTanks = Tanks.filter(t => t.color != "white" &amp;&amp; t.color != MyTank.color);

  // loop through all items
  for (let i = 0; i &lt; items.length; i += 1) {
    const pos = items[i];
    if (MyTank.r === pos.r &amp;&amp; MyTank.c === pos.c) continue;
    // calculate the absolute distance
    const dis = Math.abs(MyTank.r - pos.r) + Math.abs(MyTank.c - pos.c);
    const myTime = dis / (1 + MyTank.specialPower.speed);

    let flag = false;
    for (let j = 0; j &lt; oppoTanks.length; j += 1) {
      const oppo = oppoTanks[j];
      const oppoDis = Math.abs(oppo.r - pos.r) + Math.abs(oppo.c - pos.c);
      const oppoTime = oppoDis / (1 + oppo.specialPower.speed);
      if (oppoTime * 1.5 &lt; myTime) {
        flag = true;
        break;
      }
    }

    if (flag) continue;

    // update shortDis 
    if (shortDis === -1 || dis &lt; shortDis) {
      shortDis = dis;
      target = pos;
    }
  }
  return target;
}

function getCrystal() {
  const target = getClosestItem(Crystals);
  if (!target) return [];
  return getShortestPathCmd(graph, MyTank, target);
}

function upgradeSpecialPowers() {
  let cmd = "";
  // if no power point, return blank command cmd
  if (MyTank.powerPoint == 0 ) return cmd;
  const sp = MyTank.specialPower;

  if (MyTank.health &lt; 2000 &amp;&amp; sp.healthRegen &lt; MAX_POWER) cmd = "3";
  else if (sp.speed &lt; 2) cmd = "2";
  else if (sp.damage &lt; 2) cmd = "1";
  else if (sp.healthRegen &lt; 2) cmd = "3";
  else if (sp.speed &lt; MAX_POWER) cmd = "2";
  else if (sp.damage &lt; MAX_POWER) cmd = "1";
  else if (sp.reload &lt; MAX_POWER) cmd = "4";
  else if (sp.healthRegen &lt; MAX_POWER) cmd = "3";

  return cmd;
}

function getSpecialWeapon() {
  const myPreference = {};
  myPreference[SPECIAL_WEAPON_TYPES.LASER_GUN] = 1;
  myPreference[SPECIAL_WEAPON_TYPES.NOVA] = 2;
  myPreference[SPECIAL_WEAPON_TYPES.MISSILE] = 3;
  myPreference[SPECIAL_WEAPON_TYPES.WAY4] = 4;
  myPreference[SPECIAL_WEAPON_TYPES.SPLITTER3] = 5;
  myPreference[SPECIAL_WEAPON_TYPES.FREEZER] = 6;
  myPreference[0] = 7;

  const curPreference = myPreference[MyTank.specialWeapon.type];
  const candidates = Weapons.filter(w => myPreference[w.type] &lt; curPreference);
  const closeBestWeapon = getClosestItem(candidates);
  if (closeBestWeapon == null) return [];

  return getShortestPathCmd(graph, MyTank, closeBestWeapon);
}

function attackOpponent() {
  if (MyTank.health &lt;= 2000) return "";

  let weakestTarget = null;
  
  // go through all tanks
  for (let i = 0; i &lt; Tanks.length; i += 1) {
    const target = Tanks[i];

    if (target.tankID == MyID || target.color == MyTank.color || target.r == MyTank.r &amp;&amp; target.c == MyTank.c) {
      continue;
    }

    let toAttack = MyTank.specialPower.healthRegen > target.specialPower.healthRegen || MyTank.health > target.health;
    toAttack = toAttack &amp;&amp; (MyTank.specialPower.damage == MAX_POWER || MyTank.specialPower.reload === MAX_POWER);

    if (toAttack &amp;&amp; (!weakestTarget || target.health &lt; weakestTarget.health || target.specialPower.damage &lt; weakestTarget.specialPower.damage)) {
      weakestTarget = target;
    }
  }

  return attackTank(weakestTarget);
}

function escapeFromDanger() {
  const delta = {
    U: [0, -1],
    D: [0, 1],
    L: [-1, 0],
    R: [1, 0],
  };
  const dirs = Object.keys(delta);
  let bestDir = "";
  let lowestDS = dangerScores[MyTank.r][MyTank.c];
  for (let i = 0; i &lt; dirs.length; i += 1) {
    const dir = dirs[i];
    const newc = MyTank.c + delta[dir][0];
    const newr = MyTank.r + delta[dir][1];
    let valid = newc >= 0 &amp;&amp; newc &lt; Maze[0].length;
    valid = valid &amp;&amp; newr >= 0 &amp;&amp; newr &lt; Maze.length;
    valid = valid &amp;&amp; !['M', 'R', 'T'].includes(Maze[newr][newc]);
    if (valid &amp;&amp; dangerScores[newr][newc] &lt; lowestDS) {
      lowestDS = dangerScores[newr][newc];
      bestDir = dir;
    }
  }
  return bestDir;  
}

function getNewCommand() {
  dangerScores = getDangerScores();
  graph = createGraph();

  const cmd1 = upgradeSpecialPowers();
  if (cmd1.length > 0) return cmd1;

  // escape from danger
  const ds = dangerScores[MyTank.r][MyTank.c];
  let isInDanger = MyTank.health &lt; 1500 &amp;&amp; ds > 4;
  isInDanger = isInDanger || MyTank.specialPower.healthRegen &lt; 2 &amp;&amp; ds > 6;
  isInDanger = isInDanger || ds > 10; 
  if (isInDanger) {
    const cmd = escapeFromDanger();
    if (cmd.length > 0) return cmd;
  }

  // get a crystal
  const path = getCrystal();
  if (path.length > 0) return path[0];

  // get a weapon
  const path2 = getSpecialWeapon();
  if (path2.length > 0) return path2[0];
  
  // attack opponent tank
  const cmd2 = attackOpponent();
  if (cmd2.length > 0) return cmd2;

  // attack white tank
  const cmd = attackWhiteTank();
  if (cmd.length > 0) return cmd;

  // random command
  const r = Math.random() * 100;
  if (r > 10) return "S";
  if (r > 8) return "U";
  if (r > 6) return "D";
  if (r > 4) return "L";
  if (r > 2) return "R";
  return "";
}       
  </cleancode>
</element>

<element elementid="100" elementType="Info">
  <p>
    So far, our tanks are very strong individually, but there are no collaborations within the same team. In the next few tutorials, we will discuss how to build up teamwork in 2v2 or 3v3 games.  
  </p>
  <p>
    There are two main tasks to achieve as a team: one is to fairly allocate resources (crystals and special weapons), and the other is to effectively attack the opponent tanks as a team. Before we discuss the tasks, we need to setup the teamwork framework first, which includes: <b>team leader election</b> in this tutorial, <b>team communication</b> in next tutorial. And then, we will focus on completing the tasks in the following tutorials.
  </p>
  <p>
    Sounds like a plan? Let's get started. 
  </p>
</element>

<element elementid="110" elementType="Info">
  <p>
    Suppose we have three tanks in our team, and there is a crystal available in the battlefield. Who should get the crystal? We don't want to waste time on competing with each other within the team, so we'd like to have a team leader to allocate this crystal to the team member who needs the resource most. 
  </p>
</element>

<element elementid="120" elementType="Info"></element>
  <p>
    For example, as shown in the setup below, tank 0 and tank 2 have already collected a crystal and increased <span class="variablename">specialPower.healthRegen</span> to one. So tank 4 needs the new crystal more. The team leader will allocate the crystal to tank 4 and other team members won't compete with tank 4, although they might be closer to the crystal. 
  </p>
  <p>
    <img src="/images/allocatecrystal.jpg" style="width: 94%; height: auto; margin-left: 3%; vertical-align: top;"/>
  </p>
</element>

<element elementid="130" elementType="Info">
  <p>
    There are many critera on leader election: the strongest, the most healthy, the most voted, etc. Here, we are going to take the very simple strategy: the tank with the smallest <span class="variablenamebold">tankID</span> is the leader, until it is dead and the tank with the next smallest <span class="variablenamebold">tankID</span> will take over the leadership. See the example below. When tank 0 is dead, tank 2 takes over the leadership.
  </p>
  <p>
    <img src="/images/leaderelection.jpg" style="width: 94%; height: auto; margin-left: 3%; vertical-align: top;"/>
  </p>
</element>

<element elementid="140" elementType="Coding" condition="TestFinishedAnyResult">
  <p>
    <b>challenge: </b>Implement a new function called <span class="variablenamebold">amILeader</span>, which checks the <span class="variablename">tankID</span> of all the team members and see if <span class="variablename">MyTank</span> has the smallest <span class="variablename">tankID</span>. If yes, set <span class="variablename">MyTank.isLeader</span> to <span class="variablename">true</span>; otherwise, set it to <span class="variablename">false</span>.
  </p>
  <p>
    Call the new function at the beginning of <span class="variablename">getNewCommand</span>. And check the result from printout.
  </p>
  <code isHidden="false">
//TODO
function amILeader() {
  let smallestID = MyTank.tankID;
  for (let i = 0; i &lt; Tanks.length; i++) {
    const t = Tanks[i];
    //h0::if t is in the same team with MyTank and has smaller tankID
    ::if (t.color == MyTank.color || t.tankID &lt; smallestID) {
    ::if (t.color == MyTank.color &amp;&amp; t.tankID &lt; smallestID) {
    ::if (t.color == MyTank.color &amp;&amp; t.tankID &lt; MyTank.tankID) {
    if ( ? ) {
      smallestID = t.tankID;
    }
  }
  //h1::if MyTank has the smallestID::if (smallestID == MyTank.tankID)
  if ( ? ) {
    MyTank.isLeader = true;
  } else {
    MyTank.isLeader = false;
  }
}

function getNewCommand() {
  amILeader();
  if (MyTank.isLeader) {
    console.log("Tank " + MyTank.tankID + " is the leader!");
  }

  ......

}
//ENDTODO
  </code>
  <cleancode>
let dangerScores = null;
let graph = null;

function isBombBlockedAtPos(col, row, color) {
  // filter Tanks array
  const temp = Tanks.filter( t => t.color != color &amp;&amp; t.c == col &amp;&amp; t.r == row);
  const result = temp.length > 0 || Maze[row][col] == 'R' || Maze[row][col] == 'T';
  return result;
}

function getDangerScores() {
  const scores = createNewGraph();
  const myColor = MyTank.color;
  
  for (let i = 0; i &lt; Tanks.length; i += 1) {
    const t = Tanks[i];
    if (t.tankID == MyID || t.color == myColor) continue;
    const dscore = 1 + t.specialPower.damage;
    
    // tank facing upward
    if (t.dir == 'U') {
      for (let j = t.r - 1; j >= 0; j -= 1) {
        scores[j][t.c] += dscore;
        if (isBombBlockedAtPos(t.c, j, t.color)) break;
      }
    } else if (t.dir == 'D') { // facing downward
      for (let j = t.r + 1; j &lt; scores.length; j += 1) {
        scores[j][t.c] += dscore;
        if (isBombBlockedAtPos(t.c, j, t.color)) break;
      }
    } else if (t.dir === 'L') { // facing to the left
      for (let j = t.c - 1; j >= 0; j -= 1) {
        scores[t.r][j] += dscore;
        if (isBombBlockedAtPos(j, t.r, t.color)) break;
      }
    } else if (t.dir === 'R') { // facing to the right
      for (let j = t.c + 1; j &lt; scores[t.r].length; j += 1) {
        scores[t.r][j] += dscore;
        if (isBombBlockedAtPos(j, t.r, t.color)) break;
      }
    }
  }
  return scores;
}

function attackTank(target) {
  if (!target) return "";

  if (MyTank.r == target.r &amp;&amp; !isShellBlocked(MyTank, target)) {
    if (MyTank.c &lt; target.c &amp;&amp; MyTank.dir != "R") {
      return "R";
    } else if (MyTank.c > target.c &amp;&amp; MyTank.dir != "L") {
      return "L";
    } else {
      return "S";
    }
  } else if (MyTank.c == target.c &amp;&amp; !isShellBlocked(MyTank, target)) {
    if (MyTank.r &lt; target.r &amp;&amp; MyTank.dir != "D") {
      return "D";
    } else if (MyTank.r > target.r &amp;&amp; MyTank.dir != "U") {
      return "U";
    } else {
      return "S";
    }
  }

  const path = getShortestPathCmd(graph, MyTank, target);
  if (path.length > 0) return path[0];
  return '';
}

function attackWhiteTank() {
  const whiteTanks = Tanks.filter(tank => tank.color == 'white' &amp;&amp; 
  (MyTank.r != tank.r || MyTank.c != tank.c));
  const target = getClosestItem(whiteTanks);
  return attackTank(target);
}      

function createGraph() {
  // create a new Set to hold blocking tile types
  const blockingTileTypes = ['R', 'M', 'T'];
  // create a new graph
  const graph = createNewGraph();

  // set values of graph, 1 = pass and 0 = blockage
  for (let i = 0; i &lt; graph.length; i += 1) {
    for (let j = 0; j &lt; graph[i].length; j += 1) {
      // tile type
      const tile = Maze[i][j];
      // check if it is a blockage
      if (blockingTileTypes.includes(tile)) graph[i][j] = 0;
      else graph[i][j] = 1 + dangerScores[i][j];
    }
  }
  return graph;
}

function getClosestItem(items) {
  // initialize variables to hold shortest distance and target
  let shortDis = -1;
  let target = null;
  const oppoTanks = Tanks.filter(t => t.color != "white" &amp;&amp; t.color != MyTank.color);

  // loop through all items
  for (let i = 0; i &lt; items.length; i += 1) {
    const pos = items[i];
    if (MyTank.r === pos.r &amp;&amp; MyTank.c === pos.c) continue;
    // calculate the absolute distance
    const dis = Math.abs(MyTank.r - pos.r) + Math.abs(MyTank.c - pos.c);
    const myTime = dis / (1 + MyTank.specialPower.speed);

    let flag = false;
    for (let j = 0; j &lt; oppoTanks.length; j += 1) {
      const oppo = oppoTanks[j];
      const oppoDis = Math.abs(oppo.r - pos.r) + Math.abs(oppo.c - pos.c);
      const oppoTime = oppoDis / (1 + oppo.specialPower.speed);
      if (oppoTime * 1.5 &lt; myTime) {
        flag = true;
        break;
      }
    }

    if (flag) continue;

    // update shortDis 
    if (shortDis === -1 || dis &lt; shortDis) {
      shortDis = dis;
      target = pos;
    }
  }
  return target;
}

function getCrystal() {
  const target = getClosestItem(Crystals);
  if (!target) return [];
  return getShortestPathCmd(graph, MyTank, target);
}

function upgradeSpecialPowers() {
  let cmd = "";
  // if no power point, return blank command cmd
  if (MyTank.powerPoint == 0 ) return cmd;
  const sp = MyTank.specialPower;

  if (MyTank.health &lt; 2000 &amp;&amp; sp.healthRegen &lt; MAX_POWER) cmd = "3";
  else if (sp.speed &lt; 2) cmd = "2";
  else if (sp.damage &lt; 2) cmd = "1";
  else if (sp.healthRegen &lt; 2) cmd = "3";
  else if (sp.speed &lt; MAX_POWER) cmd = "2";
  else if (sp.damage &lt; MAX_POWER) cmd = "1";
  else if (sp.reload &lt; MAX_POWER) cmd = "4";
  else if (sp.healthRegen &lt; MAX_POWER) cmd = "3";

  return cmd;
}

function getSpecialWeapon() {
  const myPreference = {};
  myPreference[SPECIAL_WEAPON_TYPES.LASER_GUN] = 1;
  myPreference[SPECIAL_WEAPON_TYPES.NOVA] = 2;
  myPreference[SPECIAL_WEAPON_TYPES.MISSILE] = 3;
  myPreference[SPECIAL_WEAPON_TYPES.WAY4] = 4;
  myPreference[SPECIAL_WEAPON_TYPES.SPLITTER3] = 5;
  myPreference[SPECIAL_WEAPON_TYPES.FREEZER] = 6;
  myPreference[0] = 7;

  const curPreference = myPreference[MyTank.specialWeapon.type];
  const candidates = Weapons.filter(w => myPreference[w.type] &lt; curPreference);
  const closeBestWeapon = getClosestItem(candidates);
  if (closeBestWeapon == null) return [];

  return getShortestPathCmd(graph, MyTank, closeBestWeapon);
}

function attackOpponent() {
  if (MyTank.health &lt;= 2000) return "";

  let weakestTarget = null;
  
  // go through all tanks
  for (let i = 0; i &lt; Tanks.length; i += 1) {
    const target = Tanks[i];

    if (target.tankID == MyID || target.color == MyTank.color || target.r == MyTank.r &amp;&amp; target.c == MyTank.c) {
      continue;
    }

    let toAttack = MyTank.specialPower.healthRegen > target.specialPower.healthRegen || MyTank.health > target.health;
    toAttack = toAttack &amp;&amp; (MyTank.specialPower.damage == MAX_POWER || MyTank.specialPower.reload === MAX_POWER);

    if (toAttack &amp;&amp; (!weakestTarget || target.health &lt; weakestTarget.health || target.specialPower.damage &lt; weakestTarget.specialPower.damage)) {
      weakestTarget = target;
    }
  }

  return attackTank(weakestTarget);
}

function escapeFromDanger() {
  const delta = {
    U: [0, -1],
    D: [0, 1],
    L: [-1, 0],
    R: [1, 0],
  };
  const dirs = Object.keys(delta);
  let bestDir = "";
  let lowestDS = dangerScores[MyTank.r][MyTank.c];
  for (let i = 0; i &lt; dirs.length; i += 1) {
    const dir = dirs[i];
    const newc = MyTank.c + delta[dir][0];
    const newr = MyTank.r + delta[dir][1];
    let valid = newc >= 0 &amp;&amp; newc &lt; Maze[0].length;
    valid = valid &amp;&amp; newr >= 0 &amp;&amp; newr &lt; Maze.length;
    valid = valid &amp;&amp; !['M', 'R', 'T'].includes(Maze[newr][newc]);
    if (valid &amp;&amp; dangerScores[newr][newc] &lt; lowestDS) {
      lowestDS = dangerScores[newr][newc];
      bestDir = dir;
    }
  }
  return bestDir;  
}

function amILeader() {
  let smallestID = MyTank.tankID;
  for (let i = 0; i &lt; Tanks.length; i++) {
    const t = Tanks[i];
    if (t.color == MyTank.color &amp;&amp; t.tankID &lt; smallestID) {
      smallestID = t.tankID;
    }
  }
  if (smallestID == MyTank.tankID) {
    MyTank.isLeader = true;
  } else {
    MyTank.isLeader = false;
  }
}

function getNewCommand() {
  amILeader();
  if (MyTank.isLeader) {
    console.log("Tank " + MyTank.tankID + " is the leader!");
  }

  dangerScores = getDangerScores();
  graph = createGraph();

  const cmd1 = upgradeSpecialPowers();
  if (cmd1.length > 0) return cmd1;

  // escape from danger
  const ds = dangerScores[MyTank.r][MyTank.c];
  let isInDanger = MyTank.health &lt; 1500 &amp;&amp; ds > 4;
  isInDanger = isInDanger || MyTank.specialPower.healthRegen &lt; 2 &amp;&amp; ds > 6;
  isInDanger = isInDanger || ds > 10; 
  if (isInDanger) {
    const cmd = escapeFromDanger();
    if (cmd.length > 0) return cmd;
  }

  // get a crystal
  const path = getCrystal();
  if (path.length > 0) return path[0];

  // get a weapon
  const path2 = getSpecialWeapon();
  if (path2.length > 0) return path2[0];
  
  // attack opponent tank
  const cmd2 = attackOpponent();
  if (cmd2.length > 0) return cmd2;

  // attack white tank
  const cmd = attackWhiteTank();
  if (cmd.length > 0) return cmd;

  // random command
  const r = Math.random() * 100;
  if (r > 10) return "S";
  if (r > 8) return "U";
  if (r > 6) return "D";
  if (r > 4) return "L";
  if (r > 2) return "R";
  return "";
}       
  </cleancode>
</element>

<element elementid="500" elementType="Conclusion">
  <p>
    Great! Now we have a leader in our team.
  </p>
  <p>
    <b>Summary:</b> In this tutorial, we started to discuss about teamwork. We selected the tank with smallest ID as our team leader. In next tutorial, we will discuss how messages are sent to team members. 
  </p>
  <p>
    <b>Exercise: </b>Think about at least three critera of leader election and compare the pros and cons. Implement one of your ideas in <span class="variablenamebold">amILeader</span> function.
  </p>
  <p>
    Share your ideas and questions in our forum under <a href="TOBEUPDATED" target="_blank">this lesson's topic</a>.
  </p>
</element>

