<element elementid="099" elementType="InitialCode"> 
  <cleancode>
let dangerScores = null;
let graph = null;

function isBombBlockedAtPos(col, row, color) {
  // filter Tanks array
  const temp = Tanks.filter( t => t.color != color &amp;&amp; t.c == col &amp;&amp; t.r == row);
  const result = temp.length > 0 || Maze[row][col] == 'R' || Maze[row][col] == 'T';
  return result;
}

function getDangerScores() {
  const scores = createNewGraph();
  const myColor = MyTank.color;
  
  for (let i = 0; i &lt; Tanks.length; i += 1) {
    const t = Tanks[i];
    if (t.tankID == MyID || t.color == myColor) continue;
    const dscore = 1 + t.specialPower.damage;
    
    // tank facing upward
    if (t.dir == 'U') {
      for (let j = t.r - 1; j >= 0; j -= 1) {
        scores[j][t.c] += dscore;
        if (isBombBlockedAtPos(t.c, j, t.color)) break;
      }
    } else if (t.dir == 'D') { // facing downward
      for (let j = t.r + 1; j &lt; scores.length; j += 1) {
        scores[j][t.c] += dscore;
        if (isBombBlockedAtPos(t.c, j, t.color)) break;
      }
    } else if (t.dir === 'L') { // facing to the left
      for (let j = t.c - 1; j >= 0; j -= 1) {
        scores[t.r][j] += dscore;
        if (isBombBlockedAtPos(j, t.r, t.color)) break;
      }
    } else if (t.dir === 'R') { // facing to the right
      for (let j = t.c + 1; j &lt; scores[t.r].length; j += 1) {
        scores[t.r][j] += dscore;
        if (isBombBlockedAtPos(j, t.r, t.color)) break;
      }
    }
  }
  return scores;
}

function attackTank(target) {
  if (!target) return "";

  if (MyTank.r == target.r &amp;&amp; !isShellBlocked(MyTank, target)) {
    if (MyTank.c &lt; target.c &amp;&amp; MyTank.dir != "R") {
      return "R";
    } else if (MyTank.c > target.c &amp;&amp; MyTank.dir != "L") {
      return "L";
    } else {
      return "S";
    }
  } else if (MyTank.c == target.c &amp;&amp; !isShellBlocked(MyTank, target)) {
    if (MyTank.r &lt; target.r &amp;&amp; MyTank.dir != "D") {
      return "D";
    } else if (MyTank.r > target.r &amp;&amp; MyTank.dir != "U") {
      return "U";
    } else {
      return "S";
    }
  }

  const path = getShortestPathCmd(graph, MyTank, target);
  if (path.length > 0) return path[0];
  return '';
}

function attackWhiteTank() {
  const whiteTanks = Tanks.filter(tank => tank.color == 'white' &amp;&amp; 
  (MyTank.r != tank.r || MyTank.c != tank.c));
  const target = getClosestItem(whiteTanks);
  return attackTank(target);
}      

function createGraph() {
  // create a new Set to hold blocking tile types
  const blockingTileTypes = ['R', 'M', 'T'];
  // create a new graph
  const graph = createNewGraph();

  // set values of graph, 1 = pass and 0 = blockage
  for (let i = 0; i &lt; graph.length; i += 1) {
    for (let j = 0; j &lt; graph[i].length; j += 1) {
      // tile type
      const tile = Maze[i][j];
      // check if it is a blockage
      if (blockingTileTypes.includes(tile)) graph[i][j] = 0;
      else graph[i][j] = 1 + dangerScores[i][j];
    }
  }
  return graph;
}

function getClosestItem(items) {
  // initialize variables to hold shortest distance and target
  let shortDis = -1;
  let target = null;
  const oppoTanks = Tanks.filter(t => t.color != "white" &amp;&amp; t.color != MyTank.color);

  // loop through all items
  for (let i = 0; i &lt; items.length; i += 1) {
    const pos = items[i];
    if (MyTank.r === pos.r &amp;&amp; MyTank.c === pos.c) continue;
    // calculate the absolute distance
    const dis = Math.abs(MyTank.r - pos.r) + Math.abs(MyTank.c - pos.c);
    const myTime = dis / (1 + MyTank.specialPower.speed);

    let flag = false;
    for (let j = 0; j &lt; oppoTanks.length; j += 1) {
      const oppo = oppoTanks[j];
      const oppoDis = Math.abs(oppo.r - pos.r) + Math.abs(oppo.c - pos.c);
      const oppoTime = oppoDis / (1 + oppo.specialPower.speed);
      if (oppoTime * 1.5 &lt; myTime) {
        flag = true;
        break;
      }
    }

    if (flag) continue;

    // update shortDis 
    if (shortDis === -1 || dis &lt; shortDis) {
      shortDis = dis;
      target = pos;
    }
  }
  return target;
}

function getCrystal() {
  const target = getClosestItem(Crystals);
  if (!target) return [];
  return getShortestPathCmd(graph, MyTank, target);
}

function upgradeSpecialPowers() {
  let cmd = "";
  // if no power point, return blank command cmd
  if (MyTank.powerPoint == 0 ) return cmd;
  const sp = MyTank.specialPower;

  if (MyTank.health &lt; 2000 &amp;&amp; sp.healthRegen &lt; MAX_POWER) cmd = "3";
  else if (sp.speed &lt; 2) cmd = "2";
  else if (sp.damage &lt; 2) cmd = "1";
  else if (sp.healthRegen &lt; 2) cmd = "3";
  else if (sp.speed &lt; MAX_POWER) cmd = "2";
  else if (sp.damage &lt; MAX_POWER) cmd = "1";
  else if (sp.reload &lt; MAX_POWER) cmd = "4";
  else if (sp.healthRegen &lt; MAX_POWER) cmd = "3";

  return cmd;
}

function getSpecialWeapon() {
  const myPreference = {};
  myPreference[SPECIAL_WEAPON_TYPES.LASER_GUN] = 1;
  myPreference[SPECIAL_WEAPON_TYPES.NOVA] = 2;
  myPreference[SPECIAL_WEAPON_TYPES.MISSILE] = 3;
  myPreference[SPECIAL_WEAPON_TYPES.WAY4] = 4;
  myPreference[SPECIAL_WEAPON_TYPES.SPLITTER3] = 5;
  myPreference[SPECIAL_WEAPON_TYPES.FREEZER] = 6;
  myPreference[0] = 7;

  const curPreference = myPreference[MyTank.specialWeapon.type];
  const candidates = Weapons.filter(w => myPreference[w.type] &lt; curPreference);
  const closeBestWeapon = getClosestItem(candidates);
  if (closeBestWeapon == null) return [];

  return getShortestPathCmd(graph, MyTank, closeBestWeapon);
}

function attackOpponent() {
  if (MyTank.health &lt;= 2000) return "";

  let weakestTarget = null;
  
  // go through all tanks
  for (let i = 0; i &lt; Tanks.length; i += 1) {
    const target = Tanks[i];

    if (target.tankID == MyID || target.color == MyTank.color || target.r == MyTank.r &amp;&amp; target.c == MyTank.c) {
      continue;
    }

    let toAttack = MyTank.specialPower.healthRegen > target.specialPower.healthRegen || MyTank.health > target.health;
    toAttack = toAttack &amp;&amp; (MyTank.specialPower.damage == MAX_POWER || MyTank.specialPower.reload === MAX_POWER);

    if (toAttack &amp;&amp; (!weakestTarget || target.health &lt; weakestTarget.health || target.specialPower.damage &lt; weakestTarget.specialPower.damage)) {
      weakestTarget = target;
    }
  }

  return attackTank(weakestTarget);
}

function escapeFromDanger() {
  const delta = {
    U: [0, -1],
    D: [0, 1],
    L: [-1, 0],
    R: [1, 0],
  };
  const dirs = Object.keys(delta);
  let bestDir = "";
  let lowestDS = dangerScores[MyTank.r][MyTank.c];
  for (let i = 0; i &lt; dirs.length; i += 1) {
    const dir = dirs[i];
    const newc = MyTank.c + delta[dir][0];
    const newr = MyTank.r + delta[dir][1];
    let valid = newc >= 0 &amp;&amp; newc &lt; Maze[0].length;
    valid = valid &amp;&amp; newr >= 0 &amp;&amp; newr &lt; Maze.length;
    valid = valid &amp;&amp; !['M', 'R', 'T'].includes(Maze[newr][newc]);
    if (valid &amp;&amp; dangerScores[newr][newc] &lt; lowestDS) {
      lowestDS = dangerScores[newr][newc];
      bestDir = dir;
    }
  }
  return bestDir;  
}

function amILeader() {
  let smallestID = MyTank.tankID;
  for (let i = 0; i &lt; Tanks.length; i++) {
    const t = Tanks[i];
    if (t.color == MyTank.color &amp;&amp; t.tankID &lt; smallestID) {
      smallestID = t.tankID;
    }
  }
  if (smallestID == MyTank.tankID) {
    MyTank.isLeader = true;
  } else {
    MyTank.isLeader = false;
  }
}

function getNewCommand() {
  amILeader();
  if (MyTank.isLeader) {
    console.log("Tank " + MyTank.tankID + " is the leader!");
  }

  dangerScores = getDangerScores();
  graph = createGraph();

  const cmd1 = upgradeSpecialPowers();
  if (cmd1.length > 0) return cmd1;

  // escape from danger
  const ds = dangerScores[MyTank.r][MyTank.c];
  let isInDanger = MyTank.health &lt; 1500 &amp;&amp; ds > 4;
  isInDanger = isInDanger || MyTank.specialPower.healthRegen &lt; 2 &amp;&amp; ds > 6;
  isInDanger = isInDanger || ds > 10; 
  if (isInDanger) {
    const cmd = escapeFromDanger();
    if (cmd.length > 0) return cmd;
  }

  // get a crystal
  const path = getCrystal();
  if (path.length > 0) return path[0];

  // get a weapon
  const path2 = getSpecialWeapon();
  if (path2.length > 0) return path2[0];
  
  // attack opponent tank
  const cmd2 = attackOpponent();
  if (cmd2.length > 0) return cmd2;

  // attack white tank
  const cmd = attackWhiteTank();
  if (cmd.length > 0) return cmd;

  // random command
  const r = Math.random() * 100;
  if (r > 10) return "S";
  if (r > 8) return "U";
  if (r > 6) return "D";
  if (r > 4) return "L";
  if (r > 2) return "R";
  return "";
}       
  </cleancode>
</element>

<element elementid="100" elementType="Info">
  <p>
    In last tutorial, we have selected a leader in our team. The next step is to build up a commnication channel among team members, so that the leader can send messages to every member. And when the team members receive the team messages, they can follow the commands accordingly. In this tutorial, we will focus on building up this communication channel. 
  </p>
</element>

<element elementid="110" elementType="Info">
  <p>
    To build up the channel, the following two functions are needed. 
  </p>
  <p>
    <ul>
      <li>
        <span class="variablenamebold">sendMessageToTeam</span>: pre-defined and provided to your leader to send messages to all team members.
      </li>
      <li>
        <span class="variablenamebold">receiveTeamMessage</span>: to be implemented. This function will be called by the game engine when a team member (including the team leader) receives a message. 
      </li>
    </ul>
  </p>
</element>

<element elementid="160" elementType="Info">
  <p>
    Here is the flow of a sample conversation among a team. The team leader generates one command based on the current environment information, and sends it to game engine by calling function <span class="variablenamebold">sendMessageToTeam</span>. The game engine doesn't care the content of the messages, instead, it passes the messages to the team members right away, by calling function <span class="variablenamebold">receiveTeamMessage</span> on each team member, including the leader. So you can send any kinds of messages within your team as long as your team members understand the format of the messages. And you don't need to worry that the game engine would leak your messages to the opponent team.   
  </p>
  <p>
    <img src="/images/dialogflow.png" style="width: 94%; height: auto; margin-left: 3%; vertical-align: top;"/>
  </p>
</element>

<element elementid="170" elementType="Info">
  <p>
    Before Implementing function <span class="variablename">receiveTeamMessage</span>, we'll talk more about the messages to be sent. Although your messages can be in any format, there are some rules you have to follow, so that the game engine is able to forward your message to the right team members. Your message must be an object. And the message object must have a <span class="variablenamebold">senderID</span> property to contain the <span class="variablenamebold">tankID</span> of the sender.  
  </p>
  <p>
    <img src="/images/messageobject.png" style="width: 40%; height: auto; margin-left: 30%; vertical-align: top;"/>
  </p>
</element>

<element elementid="180" elementType="Info">
  <p>
    In addition, in order to have every team member understanding the messages, we'd like to define the message types beforehand. For now, let's define four types of messages. Please add the following global variables at the beginning of your tank code. And we will add one more property <span class="varaiblenamebold">type</span> in the message objects to hold the message type. 
  </p>
  <p>
    <pre class="brush:js">
const MSG_CLAIM_CRYSTAL = 1;
const MSG_CLAIM_WEAPON = 2;
const MSG_ATTACK = 3;
const MSG_UNATTACK = 4;
    </pre>
  </p>
</element>

<element elementid="190" elementType="Info">
  <p>
    To handle different types of messages, we will use a new JavaScript statement called <span class="keyword">switch</span>.
  </p>
</element>

<element elementid="200" elementType="Language" languageSkills="JavaScript:Switch">
</element>

<element elementid="210" elementType="Coding" condition="TestFinishedAnyResult">
  <p>
    <b>challenge: </b>Define the new function <span class="variablenamebold">receiveTeamMessage</span>, print out different messages based on the message types. Write down your own code and compare it with the answer by typing in <b>code</b>.
  </p>
  <code isHidden="false">
//TODO
function receiveTeamMessage(message) {
  //h0::evaluate message type::message.type
  switch ( ? ) {
    case MSG_CLAIM_CRYSTAL:
      console.log("Got message to claim a crystal.");
      break;
    // other message types 
    ???
    /// by default
    ???
  }
}
//ENDTODO
  </code>
  <cleancode>
const MSG_CLAIM_CRYSTAL = 1;
const MSG_CLAIM_WEAPON = 2;
const MSG_ATTACK = 3;
const MSG_UNATTACK = 4;

let dangerScores = null;
let graph = null;

function isBombBlockedAtPos(col, row, color) {
  // filter Tanks array
  const temp = Tanks.filter( t => t.color != color &amp;&amp; t.c == col &amp;&amp; t.r == row);
  const result = temp.length > 0 || Maze[row][col] == 'R' || Maze[row][col] == 'T';
  return result;
}

function getDangerScores() {
  const scores = createNewGraph();
  const myColor = MyTank.color;
  
  for (let i = 0; i &lt; Tanks.length; i += 1) {
    const t = Tanks[i];
    if (t.tankID == MyID || t.color == myColor) continue;
    const dscore = 1 + t.specialPower.damage;
    
    // tank facing upward
    if (t.dir == 'U') {
      for (let j = t.r - 1; j >= 0; j -= 1) {
        scores[j][t.c] += dscore;
        if (isBombBlockedAtPos(t.c, j, t.color)) break;
      }
    } else if (t.dir == 'D') { // facing downward
      for (let j = t.r + 1; j &lt; scores.length; j += 1) {
        scores[j][t.c] += dscore;
        if (isBombBlockedAtPos(t.c, j, t.color)) break;
      }
    } else if (t.dir === 'L') { // facing to the left
      for (let j = t.c - 1; j >= 0; j -= 1) {
        scores[t.r][j] += dscore;
        if (isBombBlockedAtPos(j, t.r, t.color)) break;
      }
    } else if (t.dir === 'R') { // facing to the right
      for (let j = t.c + 1; j &lt; scores[t.r].length; j += 1) {
        scores[t.r][j] += dscore;
        if (isBombBlockedAtPos(j, t.r, t.color)) break;
      }
    }
  }
  return scores;
}

function attackTank(target) {
  if (!target) return "";

  if (MyTank.r == target.r &amp;&amp; !isShellBlocked(MyTank, target)) {
    if (MyTank.c &lt; target.c &amp;&amp; MyTank.dir != "R") {
      return "R";
    } else if (MyTank.c > target.c &amp;&amp; MyTank.dir != "L") {
      return "L";
    } else {
      return "S";
    }
  } else if (MyTank.c == target.c &amp;&amp; !isShellBlocked(MyTank, target)) {
    if (MyTank.r &lt; target.r &amp;&amp; MyTank.dir != "D") {
      return "D";
    } else if (MyTank.r > target.r &amp;&amp; MyTank.dir != "U") {
      return "U";
    } else {
      return "S";
    }
  }

  const path = getShortestPathCmd(graph, MyTank, target);
  if (path.length > 0) return path[0];
  return '';
}

function attackWhiteTank() {
  const whiteTanks = Tanks.filter(tank => tank.color == 'white' &amp;&amp; 
  (MyTank.r != tank.r || MyTank.c != tank.c));
  const target = getClosestItem(whiteTanks);
  return attackTank(target);
}      

function createGraph() {
  // create a new Set to hold blocking tile types
  const blockingTileTypes = ['R', 'M', 'T'];
  // create a new graph
  const graph = createNewGraph();

  // set values of graph, 1 = pass and 0 = blockage
  for (let i = 0; i &lt; graph.length; i += 1) {
    for (let j = 0; j &lt; graph[i].length; j += 1) {
      // tile type
      const tile = Maze[i][j];
      // check if it is a blockage
      if (blockingTileTypes.includes(tile)) graph[i][j] = 0;
      else graph[i][j] = 1 + dangerScores[i][j];
    }
  }
  return graph;
}

function getClosestItem(items) {
  // initialize variables to hold shortest distance and target
  let shortDis = -1;
  let target = null;
  const oppoTanks = Tanks.filter(t => t.color != "white" &amp;&amp; t.color != MyTank.color);

  // loop through all items
  for (let i = 0; i &lt; items.length; i += 1) {
    const pos = items[i];
    if (MyTank.r === pos.r &amp;&amp; MyTank.c === pos.c) continue;
    // calculate the absolute distance
    const dis = Math.abs(MyTank.r - pos.r) + Math.abs(MyTank.c - pos.c);
    const myTime = dis / (1 + MyTank.specialPower.speed);

    let flag = false;
    for (let j = 0; j &lt; oppoTanks.length; j += 1) {
      const oppo = oppoTanks[j];
      const oppoDis = Math.abs(oppo.r - pos.r) + Math.abs(oppo.c - pos.c);
      const oppoTime = oppoDis / (1 + oppo.specialPower.speed);
      if (oppoTime * 1.5 &lt; myTime) {
        flag = true;
        break;
      }
    }

    if (flag) continue;

    // update shortDis 
    if (shortDis === -1 || dis &lt; shortDis) {
      shortDis = dis;
      target = pos;
    }
  }
  return target;
}

function getCrystal() {
  const target = getClosestItem(Crystals);
  if (!target) return [];
  return getShortestPathCmd(graph, MyTank, target);
}

function upgradeSpecialPowers() {
  let cmd = "";
  // if no power point, return blank command cmd
  if (MyTank.powerPoint == 0 ) return cmd;
  const sp = MyTank.specialPower;

  if (MyTank.health &lt; 2000 &amp;&amp; sp.healthRegen &lt; MAX_POWER) cmd = "3";
  else if (sp.speed &lt; 2) cmd = "2";
  else if (sp.damage &lt; 2) cmd = "1";
  else if (sp.healthRegen &lt; 2) cmd = "3";
  else if (sp.speed &lt; MAX_POWER) cmd = "2";
  else if (sp.damage &lt; MAX_POWER) cmd = "1";
  else if (sp.reload &lt; MAX_POWER) cmd = "4";
  else if (sp.healthRegen &lt; MAX_POWER) cmd = "3";

  return cmd;
}

function getSpecialWeapon() {
  const myPreference = {};
  myPreference[SPECIAL_WEAPON_TYPES.LASER_GUN] = 1;
  myPreference[SPECIAL_WEAPON_TYPES.NOVA] = 2;
  myPreference[SPECIAL_WEAPON_TYPES.MISSILE] = 3;
  myPreference[SPECIAL_WEAPON_TYPES.WAY4] = 4;
  myPreference[SPECIAL_WEAPON_TYPES.SPLITTER3] = 5;
  myPreference[SPECIAL_WEAPON_TYPES.FREEZER] = 6;
  myPreference[0] = 7;

  const curPreference = myPreference[MyTank.specialWeapon.type];
  const candidates = Weapons.filter(w => myPreference[w.type] &lt; curPreference);
  const closeBestWeapon = getClosestItem(candidates);
  if (closeBestWeapon == null) return [];

  return getShortestPathCmd(graph, MyTank, closeBestWeapon);
}

function attackOpponent() {
  if (MyTank.health &lt;= 2000) return "";

  let weakestTarget = null;
  
  // go through all tanks
  for (let i = 0; i &lt; Tanks.length; i += 1) {
    const target = Tanks[i];

    if (target.tankID == MyID || target.color == MyTank.color || target.r == MyTank.r &amp;&amp; target.c == MyTank.c) {
      continue;
    }

    let toAttack = MyTank.specialPower.healthRegen > target.specialPower.healthRegen || MyTank.health > target.health;
    toAttack = toAttack &amp;&amp; (MyTank.specialPower.damage == MAX_POWER || MyTank.specialPower.reload === MAX_POWER);

    if (toAttack &amp;&amp; (!weakestTarget || target.health &lt; weakestTarget.health || target.specialPower.damage &lt; weakestTarget.specialPower.damage)) {
      weakestTarget = target;
    }
  }

  return attackTank(weakestTarget);
}

function escapeFromDanger() {
  const delta = {
    U: [0, -1],
    D: [0, 1],
    L: [-1, 0],
    R: [1, 0],
  };
  const dirs = Object.keys(delta);
  let bestDir = "";
  let lowestDS = dangerScores[MyTank.r][MyTank.c];
  for (let i = 0; i &lt; dirs.length; i += 1) {
    const dir = dirs[i];
    const newc = MyTank.c + delta[dir][0];
    const newr = MyTank.r + delta[dir][1];
    let valid = newc >= 0 &amp;&amp; newc &lt; Maze[0].length;
    valid = valid &amp;&amp; newr >= 0 &amp;&amp; newr &lt; Maze.length;
    valid = valid &amp;&amp; !['M', 'R', 'T'].includes(Maze[newr][newc]);
    if (valid &amp;&amp; dangerScores[newr][newc] &lt; lowestDS) {
      lowestDS = dangerScores[newr][newc];
      bestDir = dir;
    }
  }
  return bestDir;  
}

function amILeader() {
  let smallestID = MyTank.tankID;
  for (let i = 0; i &lt; Tanks.length; i++) {
    const t = Tanks[i];
    if (t.color == MyTank.color &amp;&amp; t.tankID &lt; smallestID) {
      smallestID = t.tankID;
    }
  }
  if (smallestID == MyTank.tankID) {
    MyTank.isLeader = true;
  } else {
    MyTank.isLeader = false;
  }
}

function getNewCommand() {
  amILeader();
  if (MyTank.isLeader) {
    console.log("Tank " + MyTank.tankID + " is the leader!");
  }

  dangerScores = getDangerScores();
  graph = createGraph();

  const cmd1 = upgradeSpecialPowers();
  if (cmd1.length > 0) return cmd1;

  // escape from danger
  const ds = dangerScores[MyTank.r][MyTank.c];
  let isInDanger = MyTank.health &lt; 1500 &amp;&amp; ds > 4;
  isInDanger = isInDanger || MyTank.specialPower.healthRegen &lt; 2 &amp;&amp; ds > 6;
  isInDanger = isInDanger || ds > 10; 
  if (isInDanger) {
    const cmd = escapeFromDanger();
    if (cmd.length > 0) return cmd;
  }

  // get a crystal
  const path = getCrystal();
  if (path.length > 0) return path[0];

  // get a weapon
  const path2 = getSpecialWeapon();
  if (path2.length > 0) return path2[0];
  
  // attack opponent tank
  const cmd2 = attackOpponent();
  if (cmd2.length > 0) return cmd2;

  // attack white tank
  const cmd = attackWhiteTank();
  if (cmd.length > 0) return cmd;

  // random command
  const r = Math.random() * 100;
  if (r > 10) return "S";
  if (r > 8) return "U";
  if (r > 6) return "D";
  if (r > 4) return "L";
  if (r > 2) return "R";
  return "";
}       

function receiveTeamMessage(message) {
  switch (message.type) {
    case MSG_CLAIM_CRYSTAL:
      console.log("Got message to claim a crystal.");
      break;
    case MSG_CLAIM_WEAPON:
      console.log("Got message to claim a special weapon.");
      break;
    case MSG_ATTACK:
      console.log("got message to attack an opponent tank.");
      break;
    case MSG_UNATTACK:
      console.log("got message NOT to attack an opponent tank.");
      break;
    default:
      console.log("received undefined message type: " + message.type);
  }
}
  </cleancode>
</element>

<element elementid="500" elementType="Conclusion">
  <p>
    <b>Summary:</b> In this tutorial, we've learned how messages are sent to team members. In addition, we defined the message types and implemented the framework of function <span class="variablenamebold">receiveTeamMessage</span>. In the next few tutorials, we will continue to build up the team communication and collaboration. 
  </p>
  <p>
    <b>Exercise: </b>Design your team message format. Think about the necessary properties for each message type. 
  </p>
  <p>
    Share your ideas and questions in our forum under <a href="TOBEUPDATED" target="_blank">this lesson's topic</a>.
  </p>
</element>