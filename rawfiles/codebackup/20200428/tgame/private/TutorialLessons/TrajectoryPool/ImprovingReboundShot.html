<element elementid="099" elementType="InitialCode">
  <cleancode>
function getCueBallPlacement() {
  const legalBallIDs = world.CandidateBallList[MyID];
  for (let k = 0; k &lt; legalBallIDs.length; k ++) {
    const ballID = legalBallIDs[k];
    const ballPos = Balls[ballID];
    for (let pocketID=0; pocketID &lt;= 5; pocketID ++) {
      const pocketPos = Pockets[pocketID];
      const isBlocked = isPathBlocked(ballPos, pocketPos);
      if ( !isBlocked ) {
          return extrapolatePoints(pocketPos, ballPos, 2 * BallDiameter);  
      }
    }
  }
}


/*
Purpose: 
  To check if the current ball placement on table matches 
  with the given scenario description.

Return value: 
  - empty list "[]" if not matching 
  - an array of ball IDs corresponding to each region
*/

function matchScenario(scenario) {

  // first check number of balls left on table
  let countOfBallsOnTable = 0;
  for (let ballID=0; ballID &lt; Balls.length; ballID ++) {
    const b = Balls[ballID];
    if (b.inPocket) continue;
    // add 1 to counter for balls left on table
    countOfBallsOnTable ++;
  }

  // if the number of balls is not equal to number of regions in the scenario, no match
  if (countOfBallsOnTable != scenario.length) return [];

  // keep track of ball ID of each ball matching with a region
  let matchedBallIDs = [];

  // go through each region in the scenario array 
  for (let k=0; k &lt; scenario.length; k++) {
    const r = scenario[k];
    
    // try to find a matching ball for this region
    let found = false;

    // go through all balls 
    for (let ballID=0; ballID &lt; Balls.length; ballID ++) {
      const b = Balls[ballID];
      // ignore a ball if it is already pocketed
      if (b.inPocket) continue;

      // check ball color and coordinate against region definition
      if (b.colorType != r.colorType) continue;
      if (Math.abs(b.x - r.x) > r.width/2) continue;
      if (Math.abs(b.y - r.y) > r.height/2) continue;

      // this ball has found a matching region
      found = true;

      // record the ballID matching this region
      matchedBallIDs.push(ballID);

      // no need to search any more
      break;
    }

    // if a region doesn't have a matching ball, then not a match
    if (!found) return [];
  }

  // we have a match, and here are the ballIDs for each region
  return matchedBallIDs;
}

async function checkEndGame1() {
  const scenario = [
    {colorType: Pool.WHITE, x: -800, y: -300, width: 200, height: 150},
    {colorType: Pool.BLACK, x: 680, y: 0, width: 200, height: 200},
    {colorType: OpponentColorType, x: 125, y: 150, width: 400, height: 200},
  ];
  
  const matchedBallIDs = matchScenario(scenario);
  if (matchedBallIDs.length == 0) return null;
  
  const targetPoint = extrapolatePoints(Balls[matchedBallIDs[2]], Balls[1], BallDiameter);
  let bestCommand = {distance: 10000};
  for (let y = (Balls[0].y + Balls[1].y)/2; y &lt; Balls[1].y; y = y + 3) {
    for (let s = 18; s &lt; 29; s ++) {
      console.log("Checking y " + y + " strength " + s);

      // calculate cue ball end position given the current aim point and strength
      const cmd = {aimx: Boundaries.RIGHT_X - BallDiameter/2, aimy: y, strength: s};
      const endStates = await calculateEndState(cmd);
      cmd.distance = dist2(endStates[0], targetPoint);

      // check movement of black ball 
      const blackBallMovement = dist2(Balls[1], endStates[1]);

      // if cue ball's end position is closer to optimal point, update bestCommand
      if (cmd.distance &lt; bestCommand.distance &amp;&amp; blackBallMovement > 0) {
        console.log("new best " + cmd.distance);
        bestCommand = cmd;
      }
    }
  }
  
  return bestCommand;
}

// given endStates, what's the minimum cut angel for any ball-pocket combination
function getMinCutAngle(endStates) {
  let minAngle = 361;
  const legalBallIDs = world.CandidateBallList[MyID]; 
  for (let k = 0; k &lt; legalBallIDs.length; k ++) { 
    const ballID = legalBallIDs[k]; 
    const targetBallPos = endStates[ballID]; 
    for (let pocketID=0; pocketID &lt;= 5; pocketID ++) { 
      const cueballPos = endStates[0];
      const pocketPos = Pockets[pocketID]; 
      const aimPoint = getAimPosition(targetBallPos, pocketPos); 
      const angle = Math.abs(getCutAngle(pocketPos, aimPoint, cueballPos));

      if (angle &lt; minAngle) {
        minAngle = angle;
      }
    }
  }
  return minAngle;
}


function allOpponentBallsBlocked(endStates) {
  const opponentBallIDs = world.CandidateBallList[1 - MyID];
  const cueballPos = endStates[0];
  for (let k = 0; k &lt; opponentBallIDs.length; k++) {
    const ballID = opponentBallIDs[k];
    if (!isPathBlocked(endStates[ballID], cueballPos, endStates)) {
      return false;
    }
  }
  return true;
}


//search for any ball cluster and break it
function getCommandForBreakingCluster() {
  const legalBallIDs = world.CandidateBallList[MyID];
  
  // walk through all legal balls
  for (let k = 0; k &lt; legalBallIDs.length; k++) {
    const ballID = legalBallIDs[k];

    // walk through each ball in the "Balls" array
    for (let ballID2 = 0; ballID2 &lt; Balls.length; ballID2++) {
      // skip ballID2 if it is the same as ballID
      if ( ballID == ballID2 ) continue;

      // skip ballID2 if that ball is in pocket already
      if (Balls[ballID2].inPocket) continue;

      // calculate distance between the 2 balls
      const d = dist2(Balls[ballID], Balls[ballID2]);

      // if the distance is less than 1.5 times of ball diameter
      if ( d &lt; 1.5*BallDiameter ) {
        // found a cluster, so simply shoot at the ball with ballID
        return { aimx: Balls[ballID].x, aimy: Balls[ballID].y };
      }
    }
  }
  // no cluster found, so return null
  return null;
}

async function getCallShot() {

  // adopt special handler if there is a match
  const specialCmd1 = await checkEndGame1();
  if (specialCmd1) return specialCmd1;  

  // place holder for best command and highest probability
  let bestCommand = {prob: -1};

  // new constant representing table center
  const tableCenter = {x: 0, y: 0};
  const legalBallIDs = world.CandidateBallList[MyID];
  for (let k = 0 ; k &lt;= legalBallIDs.length-1 ; k=k+1 ) {
    const ballID = legalBallIDs[k];
    const isBlocked = isPathBlocked(Balls[ballID], Balls[0]);
    if (isBlocked) continue;

    for (let pocketID = 0; pocketID &lt;= 5 ; pocketID = pocketID + 1 ) {
      console.log("\nballID " + ballID + " pocketID " + pocketID);
      const aimPoint = getAimPosition(Balls[ballID], Pockets[pocketID]);

      const cutAngle = getCutAngle(Pockets[pocketID], aimPoint, Balls[0]);
      if (Math.abs(cutAngle) > 90) continue ;

      // iterate through strength values of 20/40/60/80
      for (let s = 20; s &lt;= 80; s = s + 20) {
        const cmd = { aimx: aimPoint.x, aimy: aimPoint.y, strength: s, targetBallID: ballID, targetPocketID: pocketID };
        
        const endStates = await calculateEndState(cmd);
        const cueballPosition = endStates[0];

        cmd.prob = await calculateProbability(cmd);
        cmd.distance = dist2(tableCenter, cueballPosition);
        cmd.minAngle = getMinCutAngle(endStates);
        console.log("Strength " + s + " prob " + cmd.prob + " cue ball " + cueballPosition.x + " " + cueballPosition.y);
        // new method to update best command 
        if (cmd.prob > 70 &amp;&amp; bestCommand.prob > 70) {
          // both commands are good enough for probability, 
          // so compare their cue ball end position
          if (cmd.minAngle &lt; bestCommand.minAngle) {
              bestCommand = cmd; 
          }
        } else {
          // simply choose the one with higher probability
          if (cmd.prob > bestCommand.prob) {
              bestCommand = cmd; 
          }
        }
      }
    }
  }

  // new behavior when we don't have a good shot
  if (bestCommand.prob >= 0 &amp;&amp; bestCommand.prob &lt; 50) {
    const targetPosOld = Balls[bestCommand.targetBallID];
    for (let s=2; s&lt;40; s=s+1) {
      console.log("trying strength " + s);
      bestCommand.strength = s;
      const endStates = await calculateEndState(bestCommand);
      const targetPosNew = endStates[bestCommand.targetBallID];
      if (targetPosOld.x != targetPosNew.x || targetPosOld.y != targetPosNew.y) {
        break;
      }
    }

    // check if end position of cue ball is blocked from all opponent balls
    const endStates = await calculateEndState(bestCommand);
    if (!allOpponentBallsBlocked(endStates)) {
      // return a command to break clusters if any
      const clusterCommand = getCommandForBreakingCluster();
      if (clusterCommand != null) return clusterCommand;

    }

  } else if (bestCommand.prob == -1) {
    // search for best kick shot command with highest success probability

    // setup the bestCommand as negative probability so it will be reassigned later
    bestCommand = {prob: -1};
    
    // iterate through all legal ball IDs
    for (let k = 0 ; k &lt;= legalBallIDs.length-1 ; k=k+1 ) {
      const ballID = legalBallIDs[k];

      // iterate through all bottom pockets
      for (let pocketID = 3; pocketID &lt;= 5 ; pocketID = pocketID + 1 ) {
        const contactPoint = getAimPosition(Balls[ballID], Pockets[pocketID]);   
        const mirrorPoint = {x: contactPoint.x, y: 2 * Boundaries.TOP_Y - contactPoint.y};

        // search for the optimal adjustment amount 
        let direction = 1;
        if (Balls[ballID].x > Balls[0].x) {
          direction = -1;
        }
        
        for (let adjustX = 0; adjustX &lt; 50; adjustX = adjustX + 1) { 
          const cmd = {aimx: mirrorPoint.x + adjustX * direction, aimy: mirrorPoint.y, strength: 45, targetBallID: ballID, targetPocketID: pocketID};    
          cmd.prob = await calculateProbability(cmd); 
          console.log("ball " + ballID + " pocket " + pocketID + " adjustX " + (adjustX * direction) + ": prob " + cmd.prob); 
          if (cmd.prob > bestCommand.prob) { 
            console.log("new best!");
            bestCommand = cmd; 
          } 
        }   
      }
    }      
  }

  // return the best command we found
  return bestCommand;
}    

function getBreakShot() {
  return { 
    aimx: 0, aimy: 0, strength: 80
  }; 
}          
                
  </cleancode>        
</element>


<element elementid="100" elementType="Info">
  <p>
    In lesson 17, you learned how to take rebound shots that utilize the cushions when you cannot make a direct shot. In this lesson, we are going to implement the other type of rebound shot - <b>bank shot</b>. 
  </p>
  <p>
    In a bank shot, the cue ball strikes the target ball directly so that the target ball bounces off a cushion and then heads towards a pocket. It will be very useful when you are close to the end of game, and your target ball is parked closely to a side cushion.
  </p>
  <p>
    For example, in the given test setup, there are no direct shot to pocket either ball 2 or ball 3, so we need to resort to bank shots to help us.
  </p>  
</element>

<element elementid="101" elementType="Info">
  <p>
    First, I have added the following code into your getCallShot function to get you started. Essentially we'll check for possible bank shots if the best command only has a probability that's 20% or lower.
  </p>
  <code isHidden="false">
// new code added to check for bank shot
if (bestCommand.prob &lt; 20) {
  const bankShotCmd = await getBankShot();
  if (bankShotCmd!=null) {
    return bankShotCmd;
  }
}
  </code>
</element>
  

<element elementid="107" elementType="Coding" condition="TestPPPocketBall_2_In_1">
  <p>
    <b>Challenge:</b> for the first step, please add a simple version of the getBankShot function right above the getCallShot function, using the following code as a template.
  </p>
  <p>
    The basic idea is very similar to the kick shot you implemented before. <b>To start simple, we only focus on ball 2 and pocket 1.</b> We first take a mirror of pocket 1 against the bottom cushion, then calculate the aim point for shooting ball 2 towards this mirror point. Then we add a for-loop to search for adjustment to this aim point in the x-direction, until we find a high probability shot.
  </p>
  <p>
    <img src="/images/mirrorpocket1bankshot.jpg" style="width: 70%; height: auto; margin-left: 15%; vertical-align: top;"/>  
  </p>
  <code isHidden="false">

//TODO: search for possible bank shots
async function getBankShot() {
  let bestCommand = {prob: -1};
  const cueballPos = Balls[0];
  const ballID = 2;
  const pocketID = 1;

  // calculate mirrored position of Pockets[pocketID] against bottom cushion at Boundaries.BOTTOM_Y
  //h0::x is unchanged through the mirror reflection::y is changed to 2 * Boundaries.BOTTOM_Y - y::write "{x: Pockets[pocketID].x, y: 2 * Boundaries.BOTTOM_Y - Pockets[pocketID].y}"
  const pocketMirror = {x: ?, y: ?};      
  const aimPoint = getAimPosition(Balls[ballID], pocketMirror);   

  // adjustX goes from -10 to 10 at step of 0.25
  //h1::the change step should be "adjustX += 0.25"::write "for (let adjustX = -10; adjustX &lt;= 10; adjustX += 0.25) { "
  for (let adjustX = ?; ?; ?) { 
    const cmd = {aimx: aimPoint.x + adjustX, aimy: aimPoint.y, strength: 45, targetBallID: ballID, targetPocketID: pocketID};    
    cmd.prob = await calculateProbability(cmd); 
    if (cmd.prob > bestCommand.prob) { 
      console.log("new best! ball " + ballID + " pocket " + pocketID + " adjustX " + adjustX + ": prob " + cmd.prob);
      bestCommand = cmd; 
    }
  }   

  if (bestCommand.prob > 50) {
    return bestCommand;
  }  
  return null;
}    
//ENDTODO
  </code>
  <cleancode>
function getCueBallPlacement() {
  const legalBallIDs = world.CandidateBallList[MyID];
  for (let k = 0; k &lt; legalBallIDs.length; k ++) {
    const ballID = legalBallIDs[k];
    const ballPos = Balls[ballID];
    for (let pocketID=0; pocketID &lt;= 5; pocketID ++) {
      const pocketPos = Pockets[pocketID];
      const isBlocked = isPathBlocked(ballPos, pocketPos);
      if ( !isBlocked ) {
          return extrapolatePoints(pocketPos, ballPos, 2 * BallDiameter);  
      }
    }
  }
}


/*
Purpose: 
  To check if the current ball placement on table matches 
  with the given scenario description.

Return value: 
  - empty list "[]" if not matching 
  - an array of ball IDs corresponding to each region
*/

function matchScenario(scenario) {

  // first check number of balls left on table
  let countOfBallsOnTable = 0;
  for (let ballID=0; ballID &lt; Balls.length; ballID ++) {
    const b = Balls[ballID];
    if (b.inPocket) continue;
    // add 1 to counter for balls left on table
    countOfBallsOnTable ++;
  }

  // if the number of balls is not equal to number of regions in the scenario, no match
  if (countOfBallsOnTable != scenario.length) return [];

  // keep track of ball ID of each ball matching with a region
  let matchedBallIDs = [];

  // go through each region in the scenario array 
  for (let k=0; k &lt; scenario.length; k++) {
    const r = scenario[k];
    
    // try to find a matching ball for this region
    let found = false;

    // go through all balls 
    for (let ballID=0; ballID &lt; Balls.length; ballID ++) {
      const b = Balls[ballID];
      // ignore a ball if it is already pocketed
      if (b.inPocket) continue;

      // check ball color and coordinate against region definition
      if (b.colorType != r.colorType) continue;
      if (Math.abs(b.x - r.x) > r.width/2) continue;
      if (Math.abs(b.y - r.y) > r.height/2) continue;

      // this ball has found a matching region
      found = true;

      // record the ballID matching this region
      matchedBallIDs.push(ballID);

      // no need to search any more
      break;
    }

    // if a region doesn't have a matching ball, then not a match
    if (!found) return [];
  }

  // we have a match, and here are the ballIDs for each region
  return matchedBallIDs;
}

async function checkEndGame1() {
  const scenario = [
    {colorType: Pool.WHITE, x: -800, y: -300, width: 200, height: 150},
    {colorType: Pool.BLACK, x: 680, y: 0, width: 200, height: 200},
    {colorType: OpponentColorType, x: 125, y: 150, width: 400, height: 200},
  ];
  
  const matchedBallIDs = matchScenario(scenario);
  if (matchedBallIDs.length == 0) return null;
  
  const targetPoint = extrapolatePoints(Balls[matchedBallIDs[2]], Balls[1], BallDiameter);
  let bestCommand = {distance: 10000};
  for (let y = (Balls[0].y + Balls[1].y)/2; y &lt; Balls[1].y; y = y + 3) {
    for (let s = 18; s &lt; 29; s ++) {
      console.log("Checking y " + y + " strength " + s);

      // calculate cue ball end position given the current aim point and strength
      const cmd = {aimx: Boundaries.RIGHT_X - BallDiameter/2, aimy: y, strength: s};
      const endStates = await calculateEndState(cmd);
      cmd.distance = dist2(endStates[0], targetPoint);

      // check movement of black ball 
      const blackBallMovement = dist2(Balls[1], endStates[1]);

      // if cue ball's end position is closer to optimal point, update bestCommand
      if (cmd.distance &lt; bestCommand.distance &amp;&amp blackBallMovement > 0) {
        console.log("new best " + cmd.distance);
        bestCommand = cmd;
      }
    }
  }
  
  return bestCommand;
}


function allOpponentBallsBlocked(endStates) {
  const opponentBallIDs = world.CandidateBallList[1 - MyID];
  const cueballPos = endStates[0];
  for (let k = 0; k &lt; opponentBallIDs.length; k++) {
    const ballID = opponentBallIDs[k];
    if (!isPathBlocked(endStates[ballID], cueballPos, endStates)) {
      return false;
    }
  }
  return true;
}


//search for any ball cluster and break it
function getCommandForBreakingCluster() {
  const legalBallIDs = world.CandidateBallList[MyID];
  
  // walk through all legal balls
  for (let k = 0; k &lt; legalBallIDs.length; k++) {
    const ballID = legalBallIDs[k];

    // walk through each ball in the "Balls" array
    for (let ballID2 = 0; ballID2 &lt; Balls.length; ballID2++) {
      // skip ballID2 if it is the same as ballID
      if ( ballID == ballID2 ) continue;

      // skip ballID2 if that ball is in pocket already
      if (Balls[ballID2].inPocket) continue;

      // calculate distance between the 2 balls
      const d = dist2(Balls[ballID], Balls[ballID2]);

      // if the distance is less than 1.5 times of ball diameter
      if ( d &lt; 1.5*BallDiameter ) {
        // found a cluster, so simply shoot at the ball with ballID
        return { aimx: Balls[ballID].x, aimy: Balls[ballID].y };
      }
    }
  }
  // no cluster found, so return null
  return null;
}

async function getBankShot() {

  let bestCommand = {prob: -1};
  const cueballPos = Balls[0];
  const ballID = 2;
  const pocketID = 1;
  const pocketMirror = {x: Pockets[pocketID].x, y: 2 * Boundaries.BOTTOM_Y - Pockets[pocketID].y};      
  const aimPoint = getAimPosition(Balls[ballID], pocketMirror);   

  for (let adjustX = -10; adjustX &lt;= 10; adjustX = adjustX + 0.25) { 
    const cmd = {aimx: aimPoint.x + adjustX, aimy: aimPoint.y, strength: 45, targetBallID: ballID, targetPocketID: pocketID};    
    cmd.prob = await calculateProbability(cmd); 
    if (cmd.prob > bestCommand.prob) { 
      console.log("new best! ball " + ballID + " pocket " + pocketID + " adjustX " + adjustX + ": prob " + cmd.prob);
      bestCommand = cmd; 
    }
  }   

  if (bestCommand.prob > 50) {
    return bestCommand;
  }  
  return null;
}    

async function getCallShot() {

  // adopt special handler if there is a match
  const specialCmd1 = await checkEndGame1();
  if (specialCmd1) return specialCmd1;  

  // place holder for best command and highest probability
  let bestCommand = {prob: -1};

  // new constant representing table center
  const tableCenter = {x: 0, y: 0};
  const legalBallIDs = world.CandidateBallList[MyID];
  for (let k = 0 ; k &lt;= legalBallIDs.length-1 ; k=k+1 ) {
    const ballID = legalBallIDs[k];
    const isBlocked = isPathBlocked(Balls[ballID], Balls[0]);
    if (isBlocked) continue;

    for (let pocketID = 0; pocketID &lt;= 5 ; pocketID = pocketID + 1 ) {
      console.log("\\nballID " + ballID + " pocketID " + pocketID);
      const aimPoint = getAimPosition(Balls[ballID], Pockets[pocketID]);

      const cutAngle = getCutAngle(Pockets[pocketID], aimPoint, Balls[0]);
      if (Math.abs(cutAngle) > 90) continue ;

      // iterate through strength values of 20/40/60/80
      for (let s = 20; s &lt;= 80; s = s + 20) {
        const cmd = { aimx: aimPoint.x, aimy: aimPoint.y, strength: s, targetBallID: ballID, targetPocketID: pocketID };
        
        const endStates = await calculateEndState(cmd);
        const cueballPosition = endStates[0];

        cmd.prob = await calculateProbability(cmd);
        cmd.distance = dist2(tableCenter, cueballPosition);
        cmd.minAngle = getMinCutAngle(endStates);
        console.log("Strength " + s + " prob " + cmd.prob + " cue ball " + cueballPosition.x + " " + cueballPosition.y);
        // new method to update best command 
        if (cmd.prob > 70 &amp;&amp bestCommand.prob > 70) {
          // both commands are good enough for probability, 
          // so compare their cue ball end position
          if (cmd.minAngle &lt; bestCommand.minAngle) {
              bestCommand = cmd; 
          }
        } else {
          // simply choose the one with higher probability
          if (cmd.prob > bestCommand.prob) {
              bestCommand = cmd; 
          }
        }
      }
    }
  }

  // new behavior when we don't have a good shot
  if (bestCommand.prob >= 0 &amp;&amp bestCommand.prob &lt; 50) {

    // new code added to check for bank shot
    if (bestCommand.prob &lt; 20) {
      const bankShotCmd = await getBankShot();
      if (bankShotCmd!=null) {
        return bankShotCmd;
      }
    }


    const targetPosOld = Balls[bestCommand.targetBallID];
    for (let s=2; s&lt;40; s=s+1) {
      console.log("trying strength " + s);
      bestCommand.strength = s;
      const endStates = await calculateEndState(bestCommand);
      const targetPosNew = endStates[bestCommand.targetBallID];
      if (targetPosOld.x != targetPosNew.x || targetPosOld.y != targetPosNew.y) {
        break;
      }
    }

    // check if end position of cue ball is blocked from all opponent balls
    const endStates = await calculateEndState(bestCommand);
    if (!allOpponentBallsBlocked(endStates)) {
      // return a command to break clusters if any
      const clusterCommand = getCommandForBreakingCluster();
      if (clusterCommand != null) return clusterCommand;

    }

  } else if (bestCommand.prob == -1) {
    // search for best kick shot command with highest success probability

    // setup the bestCommand as negative probability so it will be reassigned later
    bestCommand = {prob: -1};
    
    // iterate through all legal ball IDs
    for (let k = 0 ; k &lt;= legalBallIDs.length-1 ; k=k+1 ) {
      const ballID = legalBallIDs[k];

      // iterate through all bottom pockets
      for (let pocketID = 3; pocketID &lt;= 5 ; pocketID = pocketID + 1 ) {
        const contactPoint = getAimPosition(Balls[ballID], Pockets[pocketID]);   
        const mirrorPoint = {x: contactPoint.x, y: 2 * Boundaries.TOP_Y - contactPoint.y};

        // search for the optimal adjustment amount 
        let direction = 1;
        if (Balls[ballID].x > Balls[0].x) {
          direction = -1;
        }
        
        for (let adjustX = 0; adjustX &lt; 50; adjustX = adjustX + 1) { 
          const cmd = {aimx: mirrorPoint.x + adjustX * direction, aimy: mirrorPoint.y, strength: 45, targetBallID: ballID, targetPocketID: pocketID};    
          cmd.prob = await calculateProbability(cmd); 
          console.log("ball " + ballID + " pocket " + pocketID + " adjustX " + (adjustX * direction) + ": prob " + cmd.prob); 
          if (cmd.prob > bestCommand.prob) { 
            console.log("new best!");
            bestCommand = cmd; 
          } 
        }   
      }
    }      
  }

  // return the best command we found
  return bestCommand;
}    

function getBreakShot() {
  return { 
    aimx: 0, aimy: 0, strength: 80
  }; 
}
  </cleancode>
</element>  




  

<element elementid="110" elementType="Coding" condition="TestPPPocketBall_2_In_1">
  <p>
    Now we have handled the single case of ball 2 and pocket 1, let's extend the solution to go through all legal balls and all top pockets.
  </p>
  <p>
    <b>Challenge:</b> change your getBankShot function to add 2 nested for-loops to search through all legal balls and all 3 top pockets.
  </p>
  <code isHidden="false">

//TODO: search for possible bank shots
async function getBankShot() {
  let bestCommand = {prob: -1};
  const cueballPos = Balls[0];
  
  // get list of all legal ballIDs in an array
  //h0::use the array "world.CandidateBallList"::write "world.CandidateBallList[MyID]";
  const legalBallIDs = ?;

  // iterate through all legal ball IDs
  //h1::k should go from 0 to legalBallIDs.length-1::write "for (let k = 0 ; k &lt;= legalBallIDs.length-1 ; k=k+1 )"
  for (let k = ? ; ? ; ? ) {
    const ballID = legalBallIDs[k];
    const ballPos = Balls[ballID];
    
    // iterate through all top pockets
    //h2::pocketID should go from 0 to 2::write "for (let pocketID = 0; pocketID &lt;= 2 ; pocketID++ )"
    for (let pocketID = ?; ? ; ? ) {

      const pocketMirror = {x: Pockets[pocketID].x, y: 2 * Boundaries.BOTTOM_Y - Pockets[pocketID].y};      
      const aimPoint = getAimPosition(Balls[ballID], pocketMirror);   

      for (let adjustX = -10; adjustX &lt; 10; adjustX = adjustX + 0.25) { 
        const cmd = {aimx: aimPoint.x + adjustX, aimy: aimPoint.y, strength: 45, targetBallID: ballID, targetPocketID: pocketID};    
        cmd.prob = await calculateProbability(cmd); 
        if (cmd.prob > bestCommand.prob) { 
          console.log("new best! ball " + ballID + " pocket " + pocketID + " adjustX " + adjustX + ": prob " + cmd.prob);
          bestCommand = cmd; 
        }
      }   
    } // newly added closing bracket for pocketID loop
  } // newly added closing bracket for k loop

  if (bestCommand.prob > 50) {
    return bestCommand;
  }  
  return null;
}    
//ENDTODO
  </code>
  <cleancode>
function getCueBallPlacement() {
  const legalBallIDs = world.CandidateBallList[MyID];
  for (let k = 0; k &lt; legalBallIDs.length; k ++) {
    const ballID = legalBallIDs[k];
    const ballPos = Balls[ballID];
    for (let pocketID=0; pocketID &lt;= 5; pocketID ++) {
      const pocketPos = Pockets[pocketID];
      const isBlocked = isPathBlocked(ballPos, pocketPos);
      if ( !isBlocked ) {
          return extrapolatePoints(pocketPos, ballPos, 2 * BallDiameter);  
      }
    }
  }
}


/*
Purpose: 
  To check if the current ball placement on table matches 
  with the given scenario description.

Return value: 
  - empty list "[]" if not matching 
  - an array of ball IDs corresponding to each region
*/

function matchScenario(scenario) {

  // first check number of balls left on table
  let countOfBallsOnTable = 0;
  for (let ballID=0; ballID &lt; Balls.length; ballID ++) {
    const b = Balls[ballID];
    if (b.inPocket) continue;
    // add 1 to counter for balls left on table
    countOfBallsOnTable ++;
  }

  // if the number of balls is not equal to number of regions in the scenario, no match
  if (countOfBallsOnTable != scenario.length) return [];

  // keep track of ball ID of each ball matching with a region
  let matchedBallIDs = [];

  // go through each region in the scenario array 
  for (let k=0; k &lt; scenario.length; k++) {
    const r = scenario[k];
    
    // try to find a matching ball for this region
    let found = false;

    // go through all balls 
    for (let ballID=0; ballID &lt; Balls.length; ballID ++) {
      const b = Balls[ballID];
      // ignore a ball if it is already pocketed
      if (b.inPocket) continue;

      // check ball color and coordinate against region definition
      if (b.colorType != r.colorType) continue;
      if (Math.abs(b.x - r.x) > r.width/2) continue;
      if (Math.abs(b.y - r.y) > r.height/2) continue;

      // this ball has found a matching region
      found = true;

      // record the ballID matching this region
      matchedBallIDs.push(ballID);

      // no need to search any more
      break;
    }

    // if a region doesn't have a matching ball, then not a match
    if (!found) return [];
  }

  // we have a match, and here are the ballIDs for each region
  return matchedBallIDs;
}

async function checkEndGame1() {
  const scenario = [
    {colorType: Pool.WHITE, x: -800, y: -300, width: 200, height: 150},
    {colorType: Pool.BLACK, x: 680, y: 0, width: 200, height: 200},
    {colorType: OpponentColorType, x: 125, y: 150, width: 400, height: 200},
  ];
  
  const matchedBallIDs = matchScenario(scenario);
  if (matchedBallIDs.length == 0) return null;
  
  const targetPoint = extrapolatePoints(Balls[matchedBallIDs[2]], Balls[1], BallDiameter);
  let bestCommand = {distance: 10000};
  for (let y = (Balls[0].y + Balls[1].y)/2; y &lt; Balls[1].y; y = y + 3) {
    for (let s = 18; s &lt; 29; s ++) {
      console.log("Checking y " + y + " strength " + s);

      // calculate cue ball end position given the current aim point and strength
      const cmd = {aimx: Boundaries.RIGHT_X - BallDiameter/2, aimy: y, strength: s};
      const endStates = await calculateEndState(cmd);
      cmd.distance = dist2(endStates[0], targetPoint);

      // check movement of black ball 
      const blackBallMovement = dist2(Balls[1], endStates[1]);

      // if cue ball's end position is closer to optimal point, update bestCommand
      if (cmd.distance &lt; bestCommand.distance &amp;&amp blackBallMovement > 0) {
        console.log("new best " + cmd.distance);
        bestCommand = cmd;
      }
    }
  }
  
  return bestCommand;
}


function allOpponentBallsBlocked(endStates) {
  const opponentBallIDs = world.CandidateBallList[1 - MyID];
  const cueballPos = endStates[0];
  for (let k = 0; k &lt; opponentBallIDs.length; k++) {
    const ballID = opponentBallIDs[k];
    if (!isPathBlocked(endStates[ballID], cueballPos, endStates)) {
      return false;
    }
  }
  return true;
}


//search for any ball cluster and break it
function getCommandForBreakingCluster() {
  const legalBallIDs = world.CandidateBallList[MyID];
  
  // walk through all legal balls
  for (let k = 0; k &lt; legalBallIDs.length; k++) {
    const ballID = legalBallIDs[k];

    // walk through each ball in the "Balls" array
    for (let ballID2 = 0; ballID2 &lt; Balls.length; ballID2++) {
      // skip ballID2 if it is the same as ballID
      if ( ballID == ballID2 ) continue;

      // skip ballID2 if that ball is in pocket already
      if (Balls[ballID2].inPocket) continue;

      // calculate distance between the 2 balls
      const d = dist2(Balls[ballID], Balls[ballID2]);

      // if the distance is less than 1.5 times of ball diameter
      if ( d &lt; 1.5*BallDiameter ) {
        // found a cluster, so simply shoot at the ball with ballID
        return { aimx: Balls[ballID].x, aimy: Balls[ballID].y };
      }
    }
  }
  // no cluster found, so return null
  return null;
}

//TODO: search for possible bank shots
async function getBankShot() {
  let bestCommand = {prob: -1};
  const cueballPos = Balls[0];

  // get list of all legal ballIDs in an array
  const legalBallIDs = world.CandidateBallList[MyID];

  // iterate through all legal ball IDs
  for (let k = 0 ; k &lt;= legalBallIDs.length-1 ; k=k+1 ) {
    const ballID = legalBallIDs[k];
    const ballPos = Balls[ballID];
    
    // iterate through all top pockets
    for (let pocketID = 0; pocketID &lt;= 2 ; pocketID ++ ) {

      const pocketMirror = {x: Pockets[pocketID].x, y: 2 * Boundaries.BOTTOM_Y - Pockets[pocketID].y};      
      const aimPoint = getAimPosition(Balls[ballID], pocketMirror);   

      for (let adjustX = -10; adjustX &lt; 10; adjustX = adjustX + 0.25) { 
        const cmd = {aimx: aimPoint.x + adjustX, aimy: aimPoint.y, strength: 45, targetBallID: ballID, targetPocketID: pocketID};    
        cmd.prob = await calculateProbability(cmd); 
        if (cmd.prob > bestCommand.prob) { 
          console.log("new best! ball " + ballID + " pocket " + pocketID + " adjustX " + adjustX + ": prob " + cmd.prob);
          bestCommand = cmd; 
        }
      }   
    }
  }      

  if (bestCommand.prob > 50) {
    return bestCommand;
  }  
  return null;
}    

async function getCallShot() {

  // adopt special handler if there is a match
  const specialCmd1 = await checkEndGame1();
  if (specialCmd1) return specialCmd1;  

  // place holder for best command and highest probability
  let bestCommand = {prob: -1};

  // new constant representing table center
  const tableCenter = {x: 0, y: 0};
  const legalBallIDs = world.CandidateBallList[MyID];
  for (let k = 0 ; k &lt;= legalBallIDs.length-1 ; k=k+1 ) {
    const ballID = legalBallIDs[k];
    const isBlocked = isPathBlocked(Balls[ballID], Balls[0]);
    if (isBlocked) continue;

    for (let pocketID = 0; pocketID &lt;= 5 ; pocketID = pocketID + 1 ) {
      console.log("\\nballID " + ballID + " pocketID " + pocketID);
      const aimPoint = getAimPosition(Balls[ballID], Pockets[pocketID]);

      const cutAngle = getCutAngle(Pockets[pocketID], aimPoint, Balls[0]);
      if (Math.abs(cutAngle) > 90) continue ;

      // iterate through strength values of 20/40/60/80
      for (let s = 20; s &lt;= 80; s = s + 20) {
        const cmd = { aimx: aimPoint.x, aimy: aimPoint.y, strength: s, targetBallID: ballID, targetPocketID: pocketID };
        
        const endStates = await calculateEndState(cmd);
        const cueballPosition = endStates[0];

        cmd.prob = await calculateProbability(cmd);
        cmd.distance = dist2(tableCenter, cueballPosition);
        cmd.minAngle = getMinCutAngle(endStates);
        console.log("Strength " + s + " prob " + cmd.prob + " cue ball " + cueballPosition.x + " " + cueballPosition.y);
        // new method to update best command 
        if (cmd.prob > 70 &amp;&amp bestCommand.prob > 70) {
          // both commands are good enough for probability, 
          // so compare their cue ball end position
          if (cmd.minAngle &lt; bestCommand.minAngle) {
              bestCommand = cmd; 
          }
        } else {
          // simply choose the one with higher probability
          if (cmd.prob > bestCommand.prob) {
              bestCommand = cmd; 
          }
        }
      }
    }
  }

  // new behavior when we don't have a good shot
  if (bestCommand.prob >= 0 &amp;&amp bestCommand.prob &lt; 50) {

    // new code added to check for bank shot
    if (bestCommand.prob &lt; 20) {
      const bankShotCmd = await getBankShot();
      if (bankShotCmd!=null) {
        return bankShotCmd;
      }
    }


    const targetPosOld = Balls[bestCommand.targetBallID];
    for (let s=2; s&lt;40; s=s+1) {
      console.log("trying strength " + s);
      bestCommand.strength = s;
      const endStates = await calculateEndState(bestCommand);
      const targetPosNew = endStates[bestCommand.targetBallID];
      if (targetPosOld.x != targetPosNew.x || targetPosOld.y != targetPosNew.y) {
        break;
      }
    }

    // check if end position of cue ball is blocked from all opponent balls
    const endStates = await calculateEndState(bestCommand);
    if (!allOpponentBallsBlocked(endStates)) {
      // return a command to break clusters if any
      const clusterCommand = getCommandForBreakingCluster();
      if (clusterCommand != null) return clusterCommand;

    }

  } else if (bestCommand.prob == -1) {
    // search for best kick shot command with highest success probability

    // setup the bestCommand as negative probability so it will be reassigned later
    bestCommand = {prob: -1};
    
    // iterate through all legal ball IDs
    for (let k = 0 ; k &lt;= legalBallIDs.length-1 ; k=k+1 ) {
      const ballID = legalBallIDs[k];

      // iterate through all bottom pockets
      for (let pocketID = 3; pocketID &lt;= 5 ; pocketID = pocketID + 1 ) {
        const contactPoint = getAimPosition(Balls[ballID], Pockets[pocketID]);   
        const mirrorPoint = {x: contactPoint.x, y: 2 * Boundaries.TOP_Y - contactPoint.y};

        // search for the optimal adjustment amount 
        let direction = 1;
        if (Balls[ballID].x > Balls[0].x) {
          direction = -1;
        }
        
        for (let adjustX = 0; adjustX &lt; 50; adjustX = adjustX + 1) { 
          const cmd = {aimx: mirrorPoint.x + adjustX * direction, aimy: mirrorPoint.y, strength: 45, targetBallID: ballID, targetPocketID: pocketID};    
          cmd.prob = await calculateProbability(cmd); 
          console.log("ball " + ballID + " pocket " + pocketID + " adjustX " + (adjustX * direction) + ": prob " + cmd.prob); 
          if (cmd.prob > bestCommand.prob) { 
            console.log("new best!");
            bestCommand = cmd; 
          } 
        }   
      }
    }      
  }

  // return the best command we found
  return bestCommand;
}    

function getBreakShot() {
  return { 
    aimx: 0, aimy: 0, strength: 80
  }; 
}
  </cleancode>
</element>  

  


<element elementid="115" elementType="Coding" condition="TestPPPocketBall_3_In_4">
  <p>
    For our last change, let's change our code to consider both top and bottom pockets.
  </p>
  <p>
    The basic idea is that we only need to consider top pockets (mirrored off bottom cushions) if the cue ball is above the target ball. That is, the y coordinate of the cue ball is smaller than that of the target ball. Similarly, we only need to consider bottom pockets (mirrored off top cushions) if the cue ball is below the target ball.
  </p>
  <p>
    <b>Challenge:</b> please modify your getBankShot function using the code below as a guidance, so that you consider either top or bottom pockets depending on the relative position of the cue ball and the target ball. In fact, <b>you only need to change the range of pocketID to search and the rebound line's y coordinate based on the relative position of the cue ball and target ball</b>.
  </p>
  <code isHidden="false">

//TODO: search for possible bank shots
async function getBankShot() {
  let bestCommand = {prob: -1};
  const cueballPos = Balls[0];
  
  const legalBallIDs = world.CandidateBallList[MyID];

  for for (let k = 0 ; k &lt;= legalBallIDs.length-1 ; k++ ) {
    const ballID = legalBallIDs[k]; // target ball ID
    const ballPos = Balls[ballID];  // target ball position

    // define variables for pocketID search range
    let pocketIDStart = 0;
    let pocketIDEnd = 2;
    // define rebound line y-coordinate
    let boundY = Boundaries.BOTTOM_Y;

    // consider pocket 3 to 5 instead if cue ball is below target ball
    //h0::use pocket 3 to 5 if cue ball is below target ball::replace "?" with ">"
    if (cueballPos.y ? ballPos.y) {
      pocketIDStart = 3; 
      pocketIDEnd = 5;
      boundY = Boundaries.TOP_Y;
    }
    
    // iterate through all pockets
    //h1::use the variables pocketIDStart and pocketIDEnd::write "for (let pocketID = pocketIDStart; pocketID &lt;= pocketIDEnd ; pocketID++ )"
    for (let pocketID = ?; pocketID &lt;= ? ; pocketID++ ) {

      // calculate mirrored pocket position 
      //h2::rebound off the line at y = boundY::write "2 * boundY - Pockets[pocketID].y"
      const pocketMirror = {x: Pockets[pocketID].x, y: ?};      
      const aimPoint = getAimPosition(Balls[ballID], pocketMirror);   

      for (let adjustX = -10; adjustX &lt; 10; adjustX = adjustX + 0.25) { 
        const cmd = {aimx: aimPoint.x + adjustX, aimy: aimPoint.y, strength: 45, targetBallID: ballID, targetPocketID: pocketID};    
        cmd.prob = await calculateProbability(cmd); 
        if (cmd.prob > bestCommand.prob) { 
          console.log("new best! ball " + ballID + " pocket " + pocketID + " adjustX " + adjustX + ": prob " + cmd.prob);
          bestCommand = cmd; 
        } 
      }   
    } 
  } 

  if (bestCommand.prob > 50) {
    return bestCommand;
  }  
  return null;
}    
//ENDTODO
  </code>
  <cleancode>
function getCueBallPlacement() {
  const legalBallIDs = world.CandidateBallList[MyID];
  for (let k = 0; k &lt; legalBallIDs.length; k ++) {
    const ballID = legalBallIDs[k];
    const ballPos = Balls[ballID];
    for (let pocketID=0; pocketID &lt;= 5; pocketID ++) {
      const pocketPos = Pockets[pocketID];
      const isBlocked = isPathBlocked(ballPos, pocketPos);
      if ( !isBlocked ) {
          return extrapolatePoints(pocketPos, ballPos, 2 * BallDiameter);  
      }
    }
  }
}


/*
Purpose: 
  To check if the current ball placement on table matches 
  with the given scenario description.

Return value: 
  - empty list "[]" if not matching 
  - an array of ball IDs corresponding to each region
*/

function matchScenario(scenario) {

  // first check number of balls left on table
  let countOfBallsOnTable = 0;
  for (let ballID=0; ballID &lt; Balls.length; ballID ++) {
    const b = Balls[ballID];
    if (b.inPocket) continue;
    // add 1 to counter for balls left on table
    countOfBallsOnTable ++;
  }

  // if the number of balls is not equal to number of regions in the scenario, no match
  if (countOfBallsOnTable != scenario.length) return [];

  // keep track of ball ID of each ball matching with a region
  let matchedBallIDs = [];

  // go through each region in the scenario array 
  for (let k=0; k &lt; scenario.length; k++) {
    const r = scenario[k];
    
    // try to find a matching ball for this region
    let found = false;

    // go through all balls 
    for (let ballID=0; ballID &lt; Balls.length; ballID ++) {
      const b = Balls[ballID];
      // ignore a ball if it is already pocketed
      if (b.inPocket) continue;

      // check ball color and coordinate against region definition
      if (b.colorType != r.colorType) continue;
      if (Math.abs(b.x - r.x) > r.width/2) continue;
      if (Math.abs(b.y - r.y) > r.height/2) continue;

      // this ball has found a matching region
      found = true;

      // record the ballID matching this region
      matchedBallIDs.push(ballID);

      // no need to search any more
      break;
    }

    // if a region doesn't have a matching ball, then not a match
    if (!found) return [];
  }

  // we have a match, and here are the ballIDs for each region
  return matchedBallIDs;
}

async function checkEndGame1() {
  const scenario = [
    {colorType: Pool.WHITE, x: -800, y: -300, width: 200, height: 150},
    {colorType: Pool.BLACK, x: 680, y: 0, width: 200, height: 200},
    {colorType: OpponentColorType, x: 125, y: 150, width: 400, height: 200},
  ];
  
  const matchedBallIDs = matchScenario(scenario);
  if (matchedBallIDs.length == 0) return null;
  
  const targetPoint = extrapolatePoints(Balls[matchedBallIDs[2]], Balls[1], BallDiameter);
  let bestCommand = {distance: 10000};
  for (let y = (Balls[0].y + Balls[1].y)/2; y &lt; Balls[1].y; y = y + 3) {
    for (let s = 18; s &lt; 29; s ++) {
      console.log("Checking y " + y + " strength " + s);

      // calculate cue ball end position given the current aim point and strength
      const cmd = {aimx: Boundaries.RIGHT_X - BallDiameter/2, aimy: y, strength: s};
      const endStates = await calculateEndState(cmd);
      cmd.distance = dist2(endStates[0], targetPoint);

      // check movement of black ball 
      const blackBallMovement = dist2(Balls[1], endStates[1]);

      // if cue ball's end position is closer to optimal point, update bestCommand
      if (cmd.distance &lt; bestCommand.distance &amp;&amp blackBallMovement > 0) {
        console.log("new best " + cmd.distance);
        bestCommand = cmd;
      }
    }
  }
  
  return bestCommand;
}


function allOpponentBallsBlocked(endStates) {
  const opponentBallIDs = world.CandidateBallList[1 - MyID];
  const cueballPos = endStates[0];
  for (let k = 0; k &lt; opponentBallIDs.length; k++) {
    const ballID = opponentBallIDs[k];
    if (!isPathBlocked(endStates[ballID], cueballPos, endStates)) {
      return false;
    }
  }
  return true;
}


//search for any ball cluster and break it
function getCommandForBreakingCluster() {
  const legalBallIDs = world.CandidateBallList[MyID];
  
  // walk through all legal balls
  for (let k = 0; k &lt; legalBallIDs.length; k++) {
    const ballID = legalBallIDs[k];

    // walk through each ball in the "Balls" array
    for (let ballID2 = 0; ballID2 &lt; Balls.length; ballID2++) {
      // skip ballID2 if it is the same as ballID
      if ( ballID == ballID2 ) continue;

      // skip ballID2 if that ball is in pocket already
      if (Balls[ballID2].inPocket) continue;

      // calculate distance between the 2 balls
      const d = dist2(Balls[ballID], Balls[ballID2]);

      // if the distance is less than 1.5 times of ball diameter
      if ( d &lt; 1.5*BallDiameter ) {
        // found a cluster, so simply shoot at the ball with ballID
        return { aimx: Balls[ballID].x, aimy: Balls[ballID].y };
      }
    }
  }
  // no cluster found, so return null
  return null;
}

//TODO: search for possible bank shots
async function getBankShot() {
  let bestCommand = {prob: -1};
  const cueballPos = Balls[0];
  
  const legalBallIDs = world.CandidateBallList[MyID];

  for for (let k = 0 ; k &lt;= legalBallIDs.length-1 ; k++ ) {
    const ballID = legalBallIDs[k]; // target ball ID
    const ballPos = Balls[ballID];  // target ball position

    // define variables for pocketID search range
    let pocketIDStart = 0;
    let pocketIDEnd = 2;
    // define rebound line y-coordinate
    let boundY = Boundaries.BOTTOM_Y;

    // consider pocket 3 to 5 instead if cue ball is below target ball
    if (cueballPos.y > ballPos.y) {
      pocketIDStart = 3; 
      pocketIDEnd = 5;
      boundY = Boundaries.TOP_Y;
    }
    
    // iterate through all pockets
    for (let pocketID = pocketIDStart; pocketID &lt;= pocketIDEnd ; pocketID++ ) {

      // calculate mirrored pocket position 
      const pocketMirror = {x: Pockets[pocketID].x, y: 2 * boundY - Pockets[pocketID].y};      
      const aimPoint = getAimPosition(Balls[ballID], pocketMirror);   

      for (let adjustX = -10; adjustX &lt; 10; adjustX = adjustX + 0.25) { 
        const cmd = {aimx: aimPoint.x + adjustX, aimy: aimPoint.y, strength: 45, targetBallID: ballID, targetPocketID: pocketID};    
        cmd.prob = await calculateProbability(cmd); 
        if (cmd.prob > bestCommand.prob) { 
          console.log("new best! ball " + ballID + " pocket " + pocketID + " adjustX " + adjustX + ": prob " + cmd.prob);
          bestCommand = cmd; 
        } 
      }   
    } 
  } 

  if (bestCommand.prob > 50) {
    return bestCommand;
  }  
  return null;
}    

async function getCallShot() {

  // adopt special handler if there is a match
  const specialCmd1 = await checkEndGame1();
  if (specialCmd1) return specialCmd1;  

  // place holder for best command and highest probability
  let bestCommand = {prob: -1};

  // new constant representing table center
  const tableCenter = {x: 0, y: 0};
  const legalBallIDs = world.CandidateBallList[MyID];
  for (let k = 0 ; k &lt;= legalBallIDs.length-1 ; k=k+1 ) {
    const ballID = legalBallIDs[k];
    const isBlocked = isPathBlocked(Balls[ballID], Balls[0]);
    if (isBlocked) continue;

    for (let pocketID = 0; pocketID &lt;= 5 ; pocketID = pocketID + 1 ) {
      console.log("\\nballID " + ballID + " pocketID " + pocketID);
      const aimPoint = getAimPosition(Balls[ballID], Pockets[pocketID]);

      const cutAngle = getCutAngle(Pockets[pocketID], aimPoint, Balls[0]);
      if (Math.abs(cutAngle) > 90) continue ;

      // iterate through strength values of 20/40/60/80
      for (let s = 20; s &lt;= 80; s = s + 20) {
        const cmd = { aimx: aimPoint.x, aimy: aimPoint.y, strength: s, targetBallID: ballID, targetPocketID: pocketID };
        
        const endStates = await calculateEndState(cmd);
        const cueballPosition = endStates[0];

        cmd.prob = await calculateProbability(cmd);
        cmd.distance = dist2(tableCenter, cueballPosition);
        cmd.minAngle = getMinCutAngle(endStates);
        console.log("Strength " + s + " prob " + cmd.prob + " cue ball " + cueballPosition.x + " " + cueballPosition.y);
        // new method to update best command 
        if (cmd.prob > 70 &amp;&amp bestCommand.prob > 70) {
          // both commands are good enough for probability, 
          // so compare their cue ball end position
          if (cmd.minAngle &lt; bestCommand.minAngle) {
              bestCommand = cmd; 
          }
        } else {
          // simply choose the one with higher probability
          if (cmd.prob > bestCommand.prob) {
              bestCommand = cmd; 
          }
        }
      }
    }
  }

  // new behavior when we don't have a good shot
  if (bestCommand.prob >= 0 &amp;&amp bestCommand.prob &lt; 50) {

    // new code added to check for bank shot
    if (bestCommand.prob &lt; 20) {
      const bankShotCmd = await getBankShot();
      if (bankShotCmd!=null) {
        return bankShotCmd;
      }
    }


    const targetPosOld = Balls[bestCommand.targetBallID];
    for (let s=2; s&lt;40; s=s+1) {
      console.log("trying strength " + s);
      bestCommand.strength = s;
      const endStates = await calculateEndState(bestCommand);
      const targetPosNew = endStates[bestCommand.targetBallID];
      if (targetPosOld.x != targetPosNew.x || targetPosOld.y != targetPosNew.y) {
        break;
      }
    }

    // check if end position of cue ball is blocked from all opponent balls
    const endStates = await calculateEndState(bestCommand);
    if (!allOpponentBallsBlocked(endStates)) {
      // return a command to break clusters if any
      const clusterCommand = getCommandForBreakingCluster();
      if (clusterCommand != null) return clusterCommand;

    }

  } else if (bestCommand.prob == -1) {
    // search for best kick shot command with highest success probability

    // setup the bestCommand as negative probability so it will be reassigned later
    bestCommand = {prob: -1};
    
    // iterate through all legal ball IDs
    for (let k = 0 ; k &lt;= legalBallIDs.length-1 ; k=k+1 ) {
      const ballID = legalBallIDs[k];

      // iterate through all bottom pockets
      for (let pocketID = 3; pocketID &lt;= 5 ; pocketID = pocketID + 1 ) {
        const contactPoint = getAimPosition(Balls[ballID], Pockets[pocketID]);   
        const mirrorPoint = {x: contactPoint.x, y: 2 * Boundaries.TOP_Y - contactPoint.y};

        // search for the optimal adjustment amount 
        let direction = 1;
        if (Balls[ballID].x > Balls[0].x) {
          direction = -1;
        }
        
        for (let adjustX = 0; adjustX &lt; 50; adjustX = adjustX + 1) { 
          const cmd = {aimx: mirrorPoint.x + adjustX * direction, aimy: mirrorPoint.y, strength: 45, targetBallID: ballID, targetPocketID: pocketID};    
          cmd.prob = await calculateProbability(cmd); 
          console.log("ball " + ballID + " pocket " + pocketID + " adjustX " + (adjustX * direction) + ": prob " + cmd.prob); 
          if (cmd.prob > bestCommand.prob) { 
            console.log("new best!");
            bestCommand = cmd; 
          } 
        }   
      }
    }      
  }

  // return the best command we found
  return bestCommand;
}    

function getBreakShot() {
  return { 
    aimx: 0, aimy: 0, strength: 80
  }; 
}
  </cleancode>
</element>  
  

  
<element elementid="200" elementType="Conclusion">
  <p>Good job!</p>
  <p><b>Summary:</b> you have added the bank shot capability to your game bot for rebounding off both the top and bottom cushions. Try to test your code by changing the placement of ball 2 or 3 in your test script to see how well it works.
  </p>
  <p>
    <b>Open Directions:</b> there are a lot of further improvements that can be made, and here are some ideas for you to get started.
  </p>
  <p>
    <ul>
      <li>
        <b>Rebounding off left or right cushions: </b> for example, if your target ball is parked next to the right cushion, sometimes you need to target the pocket 0 or 5 with a bank shot against the right cushion.
      </li>
      <li>
        <b>Try different strength and spin: </b> in the implementation given in this lesson, we simply set the strength to 45 and uses no spins. You can add more nested for-loops to consider different values for these properties.
      </li>
      <li>
        <b>Optimize cue ball end position:</b> in case you get high probability bank shots (say probability > 70), you might want to consider the end position of the cue ball after the bank shot, similar to what you have done in lesson 14.
      </li>
    </ul>
  </p>
  <p>
    If you want to discuss any implementation or new idea with others, feel free to discuss in our forum.
  </p>
</element>
    