<element elementid="099" elementType="InitialCode">
  <cleancode>
function getCueBallPlacement() {
  const legalBallIDs = world.CandidateBallList[MyID];
  for (let k = 0; k &lt; legalBallIDs.length; k ++) {
    const ballID = legalBallIDs[k];
    const ballPos = Balls[ballID];
    for (let pocketID=0; pocketID &lt;= 5; pocketID ++) {
      const pocketPos = Pockets[pocketID];
      const isBlocked = isPathBlocked(ballPos, pocketPos);
      if ( !isBlocked ) {
          return extrapolatePoints(pocketPos, ballPos, 2 * BallDiameter);  
      }
    }
  }
}


/*
Purpose: 
  To check if the current ball placement on table matches 
  with the given scenario description.

Return value: 
  - empty list "[]" if not matching 
  - an array of ball IDs corresponding to each region
*/

function matchScenario(scenario) {

  // first check number of balls left on table
  let countOfBallsOnTable = 0;
  for (let ballID=0; ballID &lt; Balls.length; ballID ++) {
    const b = Balls[ballID];
    if (b.inPocket) continue;
    // add 1 to counter for balls left on table
    countOfBallsOnTable ++;
  }

  // if the number of balls is not equal to number of regions in the scenario, no match
  if (countOfBallsOnTable != scenario.length) return [];

  // keep track of ball ID of each ball matching with a region
  let matchedBallIDs = [];

  // go through each region in the scenario array 
  for (let k=0; k &lt; scenario.length; k++) {
    const r = scenario[k];
    
    // try to find a matching ball for this region
    let found = false;

    // go through all balls 
    for (let ballID=0; ballID &lt; Balls.length; ballID ++) {
      const b = Balls[ballID];
      // ignore a ball if it is already pocketed
      if (b.inPocket) continue;

      // check ball color and coordinate against region definition
      if (b.colorType != r.colorType) continue;
      if (Math.abs(b.x - r.x) > r.width/2) continue;
      if (Math.abs(b.y - r.y) > r.height/2) continue;

      // this ball has found a matching region
      found = true;

      // record the ballID matching this region
      matchedBallIDs.push(ballID);

      // no need to search any more
      break;
    }

    // if a region doesn't have a matching ball, then not a match
    if (!found) return [];
  }

  // we have a match, and here are the ballIDs for each region
  return matchedBallIDs;
}

async function checkEndGame1() {
  const scenario = [
    {colorType: Pool.WHITE, x: -800, y: -300, width: 200, height: 150},
    {colorType: Pool.BLACK, x: 680, y: 0, width: 200, height: 200},
    {colorType: OpponentColorType, x: 125, y: 150, width: 400, height: 200},
  ];
  
  const matchedBallIDs = matchScenario(scenario);
  if (matchedBallIDs.length == 0) return null;
  
  const targetPoint = extrapolatePoints(Balls[matchedBallIDs[2]], Balls[1], BallDiameter);
  let bestCommand = {distance: 10000};
  for (let y = (Balls[0].y + Balls[1].y)/2; y &lt; Balls[1].y; y = y + 3) {
    for (let s = 18; s &lt; 29; s ++) {
      console.log("Checking y " + y + " strength " + s);

      // calculate cue ball end position given the current aim point and strength
      const cmd = {aimx: Boundaries.RIGHT_X - BallDiameter/2, aimy: y, strength: s};
      const endStates = await calculateEndState(cmd);
      cmd.distance = dist2(endStates[0], targetPoint);

      // check movement of black ball 
      const blackBallMovement = dist2(Balls[1], endStates[1]);

      // if cue ball's end position is closer to optimal point, update bestCommand
      if (cmd.distance &lt; bestCommand.distance &amp;&amp; blackBallMovement > 0) {
        console.log("new best " + cmd.distance);
        bestCommand = cmd;
      }
    }
  }
  
  return bestCommand;
}


// given endStates, what's the minimum cut angel for any ball-pocket combination
function getMinCutAngle(endStates) {
  let minAngle = 361;
  const legalBallIDs = world.CandidateBallList[MyID]; 
  for (let k = 0; k &lt; legalBallIDs.length; k ++) { 
    const ballID = legalBallIDs[k]; 
    const targetBallPos = endStates[ballID]; 
    for (let pocketID=0; pocketID &lt;= 5; pocketID ++) { 
      const cueballPos = endStates[0];
      const pocketPos = Pockets[pocketID]; 
      const aimPoint = getAimPosition(targetBallPos, pocketPos); 
      const angle = Math.abs(getCutAngle(pocketPos, aimPoint, cueballPos));

      if (angle &lt; minAngle) {
        minAngle = angle;
      }
    }
  }
  return minAngle;
}

async function getCallShot() {

  // adopt special handler if there is a match
  const specialCmd1 = await checkEndGame1();
  if (specialCmd1) return specialCmd1;  

  // place holder for best command and highest probability
  let bestCommand = {prob: -1};

  // new constant representing table center
  const tableCenter = {x: 0, y: 0};
  const legalBallIDs = world.CandidateBallList[MyID];
  for (let k = 0 ; k &lt;= legalBallIDs.length-1 ; k=k+1 ) {
    const ballID = legalBallIDs[k];
    const isBlocked = isPathBlocked(Balls[ballID], Balls[0]);
    if (isBlocked) continue;

    for (let pocketID = 0; pocketID &lt;= 5 ; pocketID = pocketID + 1 ) {
      console.log("\nballID " + ballID + " pocketID " + pocketID);
      const aimPoint = getAimPosition(Balls[ballID], Pockets[pocketID]);

      const cutAngle = getCutAngle(Pockets[pocketID], aimPoint, Balls[0]);
      if (Math.abs(cutAngle) > 90) continue ;

      // iterate through strength values of 20/40/60/80
      for (let s = 20; s &lt;= 80; s = s + 20) {
        const cmd = { aimx: aimPoint.x, aimy: aimPoint.y, strength: s, targetBallID: ballID, targetPocketID: pocketID };
        
        const endStates = await calculateEndState(cmd);
        const cueballPosition = endStates[0];

        cmd.prob = await calculateProbability(cmd);
        cmd.distance = dist2(tableCenter, cueballPosition);
        cmd.minAngle = getMinCutAngle(endStates);
        console.log("Strength " + s + " prob " + cmd.prob + " cue ball " + cueballPosition.x + " " + cueballPosition.y);
        // new method to update best command 
        if (cmd.prob > 70 &amp;&amp; bestCommand.prob > 70) {
          // both commands are good enough for probability, 
          // so compare their cue ball end position
          if (cmd.minAngle &lt; bestCommand.minAngle) {
              bestCommand = cmd; 
          }
        } else {
          // simply choose the one with higher probability
          if (cmd.prob > bestCommand.prob) {
              bestCommand = cmd; 
          }
        }
      }
    }
  }

  // new behavior when we don't have a good shot
  if (bestCommand.prob >= 0 &amp;&amp; bestCommand.prob &lt; 50) {
    const targetPosOld = Balls[bestCommand.targetBallID];
    for (let s=2; s&lt;40; s=s+1) {
      console.log("trying strength " + s);
      bestCommand.strength = s;
      const endStates = await calculateEndState(bestCommand);
      const targetPosNew = endStates[bestCommand.targetBallID];
      if (targetPosOld.x != targetPosNew.x || targetPosOld.y != targetPosNew.y) {
        break;
      }
    }

    // new code added for lesson 20

    // check if end position of cue ball is blocked from all opponent balls
    const endStates = await calculateEndState(bestCommand);
    if (!allOpponentBallsBlocked(endStates)) {
      // return a command to break clusters if any
      const clusterCommand = getCommandForBreakingCluster();
      if (clusterCommand != null) return clusterCommand;

    }
    // end of new code

  } else if (bestCommand.prob == -1) {
    // search for best kick shot command with highest success probability

    // setup the bestCommand as negative probability so it will be reassigned later
    bestCommand = {prob: -1};
    
    // iterate through all legal ball IDs
    for (let k = 0 ; k &lt;= legalBallIDs.length-1 ; k=k+1 ) {
      const ballID = legalBallIDs[k];

      // iterate through all bottom pockets
      for (let pocketID = 3; pocketID &lt;= 5 ; pocketID = pocketID + 1 ) {
        const contactPoint = getAimPosition(Balls[ballID], Pockets[pocketID]);   
        const mirrorPoint = {x: contactPoint.x, y: 2 * Boundaries.TOP_Y - contactPoint.y};

        // search for the optimal adjustment amount 
        let direction = 1;
        if (Balls[ballID].x > Balls[0].x) {
          direction = -1;
        }
        
        for (let adjustX = 0; adjustX &lt; 50; adjustX = adjustX + 1) { 
          const cmd = {aimx: mirrorPoint.x + adjustX * direction, aimy: mirrorPoint.y, strength: 45, targetBallID: ballID, targetPocketID: pocketID};    
          cmd.prob = await calculateProbability(cmd); 
          console.log("ball " + ballID + " pocket " + pocketID + " adjustX " + (adjustX * direction) + ": prob " + cmd.prob); 
          if (cmd.prob > bestCommand.prob) { 
            console.log("new best!");
            bestCommand = cmd; 
          } 
        }   
      }
    }      
  }

  // return the best command we found
  return bestCommand;
}    

function getBreakShot() {
  return { 
    aimx: 0, aimy: 0, strength: 80
  }; 
}          
  </cleancode>        
</element>


<element elementid="100" elementType="Info">
  <p>
    Recall that in lesson 15, you implemented a simple strategy to play a safety shot: when you can't find a high probability shot command, shoot very softly to barely touch your target ball.  
  </p>
  <p>
    Very often this hides the cue ball behind your ball, causing headaches for your opponent. However, sometimes not all opponent balls are blocked. For example, in the test setup given in this lesson, <b>the yellow ball 5 will not be blocked</b> when you hit the cue ball softly towards ball 2.
  </p>
  <p>
    So what should we do in such situations?
  </p>
</element>

<element elementid="101" elementType="Info">
  <p>
    When you can't find a good shot, very often it is because your target ball is clustered with other balls. So a promising enhancement is to <b>break a ball cluster when the initial safety shot is not working</b>.
  </p>
  <p>
    The following code has been added to your robot code to get you started. The idea is if not all opponent balls are blocked from the cue ball after the best safety shot command, then try to find a command that breaks a ball cluster for you. 
  </p>
  <code isHidden="false">
// new code added for lesson 20

// check if end position of cue ball is blocked from all opponent balls
const endStates = await calculateEndState(bestCommand);
if (!allOpponentBallsBlocked(endStates)) {
  // is there a command to break clusters?
  const clusterCommand = getCommandForBreakingCluster();
  // if so, return that command
  if (clusterCommand != null) return clusterCommand;
}
// end of new code
  </code>
</element>


<element elementid="103" elementType="Info">
  <p>
    Now let's implement a simple version of the new function "getCommandForBreakingCluster" first, which simply returns a command to shoot at table center.
  </p>
  <p>
    <b>Challenge:</b> please add the getCommandForBreakingCluster function using the guidance below, right below the new allOpponentBallsBlocked function. When you click "Test", your bot should find that after the safety shot, not all opponent balls are blocked, so it simply uses the command from the getCommandForBreakingCluster function, which aims at the table center.
  </p>
  <code isHidden="false">
//TODO: first implementation of the getCommandForBreakingCluster function
function getCommandForBreakingCluster() {
  // return a command that shoots at table center 
  //h0::write "{aimx: 0, aimy: 0}"
  return { ?, ? };
}
//ENDTODO
  </code>
</element>

<element elementid="104" elementType="Coding" condition="TestFinishedAnyResult_AimXY00">
  <p>
    <b>Challenge: </b> now let's implement the <b>allOpponentBallsBlocked</b> function, using the following code as a guidance. Basically it takes an endStates array as input, and determines if the cue ball is blocked from all opponent balls in the given end state. <b>Please add this new function right above the getCallShot function.</b>
  </p>
    <p>
    Note that for the "isPathBlocked" function, since we are testing for blockage given the endStates of balls (as opposed to the current position of balls), we need to pass in a third parameter <b>endStates</b> to the isPathBlocked function call.
  </p>
  <p>
    When you click "test", your bot should find that after the safety shot, not all opponent balls are blocked. So it will simply adopt the command from the getCommandForBreakingCluster function, which aims at the table center.
  </p>
  <code isHidden="false">
//TODO: implement allOpponentBallsBlocked
function allOpponentBallsBlocked(endStates) {
  // get all ball IDs for opponent
  const opponentBallIDs = world.CandidateBallList[1 - MyID];
  // read the end position of the cue ball
  //h0::read from array endStates::write "endStates[0]"
  const cueballPos = ?;

  // walk through all ballIDs in the opponentBallIDs array
  //h1::k should range from 0 to opponentBallIDs.length-1::write "for (let k = 0; k &lt; opponentBallIDs.length; k++)"
  for (let k = ?; ? ; ?) {
    //h2::ballID should be k-th item in the array opponentBallIDs::write "opponentBallIDs[k]"
    const ballID = ?;
    // check if this opponent ball is blocked given end states
    if (!isPathBlocked(endStates[ballID], cueballPos, endStates)) {
      //h3::if this opponent ball is not blocked, return false
      return ?;
    }
  }
  // we didn't find any unblocked opponent ball
  return true;
}
//ENDTODO
  </code>
  <cleancode>
function getCueBallPlacement() {
  const legalBallIDs = world.CandidateBallList[MyID];
  for (let k = 0; k &lt; legalBallIDs.length; k ++) {
    const ballID = legalBallIDs[k];
    const ballPos = Balls[ballID];
    for (let pocketID=0; pocketID &lt;= 5; pocketID ++) {
      const pocketPos = Pockets[pocketID];
      const isBlocked = isPathBlocked(ballPos, pocketPos);
      if ( !isBlocked ) {
          return extrapolatePoints(pocketPos, ballPos, 2 * BallDiameter);  
      }
    }
  }
}


/*
Purpose: 
  To check if the current ball placement on table matches 
  with the given scenario description.

Return value: 
  - empty list "[]" if not matching 
  - an array of ball IDs corresponding to each region
*/

function matchScenario(scenario) {

  // first check number of balls left on table
  let countOfBallsOnTable = 0;
  for (let ballID=0; ballID &lt; Balls.length; ballID ++) {
    const b = Balls[ballID];
    if (b.inPocket) continue;
    // add 1 to counter for balls left on table
    countOfBallsOnTable ++;
  }

  // if the number of balls is not equal to number of regions in the scenario, no match
  if (countOfBallsOnTable != scenario.length) return [];

  // keep track of ball ID of each ball matching with a region
  let matchedBallIDs = [];

  // go through each region in the scenario array 
  for (let k=0; k &lt; scenario.length; k++) {
    const r = scenario[k];
    
    // try to find a matching ball for this region
    let found = false;

    // go through all balls 
    for (let ballID=0; ballID &lt; Balls.length; ballID ++) {
      const b = Balls[ballID];
      // ignore a ball if it is already pocketed
      if (b.inPocket) continue;

      // check ball color and coordinate against region definition
      if (b.colorType != r.colorType) continue;
      if (Math.abs(b.x - r.x) > r.width/2) continue;
      if (Math.abs(b.y - r.y) > r.height/2) continue;

      // this ball has found a matching region
      found = true;

      // record the ballID matching this region
      matchedBallIDs.push(ballID);

      // no need to search any more
      break;
    }

    // if a region doesn't have a matching ball, then not a match
    if (!found) return [];
  }

  // we have a match, and here are the ballIDs for each region
  return matchedBallIDs;
}

async function checkEndGame1() {
  const scenario = [
    {colorType: Pool.WHITE, x: -800, y: -300, width: 200, height: 150},
    {colorType: Pool.BLACK, x: 680, y: 0, width: 200, height: 200},
    {colorType: OpponentColorType, x: 125, y: 150, width: 400, height: 200},
  ];
  
  const matchedBallIDs = matchScenario(scenario);
  if (matchedBallIDs.length == 0) return null;
  
  const targetPoint = extrapolatePoints(Balls[matchedBallIDs[2]], Balls[1], BallDiameter);
  let bestCommand = {distance: 10000};
  for (let y = (Balls[0].y + Balls[1].y)/2; y &lt; Balls[1].y; y = y + 3) {
    for (let s = 18; s &lt; 29; s ++) {
      console.log("Checking y " + y + " strength " + s);

      // calculate cue ball end position given the current aim point and strength
      const cmd = {aimx: Boundaries.RIGHT_X - BallDiameter/2, aimy: y, strength: s};
      const endStates = await calculateEndState(cmd);
      cmd.distance = dist2(endStates[0], targetPoint);

      // check movement of black ball 
      const blackBallMovement = dist2(Balls[1], endStates[1]);

      // if cue ball's end position is closer to optimal point, update bestCommand
      if (cmd.distance &lt; bestCommand.distance &amp;&amp; blackBallMovement > 0) {
        console.log("new best " + cmd.distance);
        bestCommand = cmd;
      }
    }
  }
  
  return bestCommand;
}

// given endStates, what's the minimum cut angel for any ball-pocket combination
function getMinCutAngle(endStates) {
  let minAngle = 361;
  const legalBallIDs = world.CandidateBallList[MyID]; 
  for (let k = 0; k &lt; legalBallIDs.length; k ++) { 
    const ballID = legalBallIDs[k]; 
    const targetBallPos = endStates[ballID]; 
    for (let pocketID=0; pocketID &lt;= 5; pocketID ++) { 
      const cueballPos = endStates[0];
      const pocketPos = Pockets[pocketID]; 
      const aimPoint = getAimPosition(targetBallPos, pocketPos); 
      const angle = Math.abs(getCutAngle(pocketPos, aimPoint, cueballPos));

      if (angle &lt; minAngle) {
        minAngle = angle;
      }
    }
  }
  return minAngle;
}


function getCommandForBreakingCluster() {
  return { aimx: 0, aimy: 0 };
}

function allOpponentBallsBlocked(endStates) {
  const opponentBallIDs = world.CandidateBallList[1 - MyID];
  const cueballPos = endStates[0];
  for (let k = 0; k &lt; opponentBallIDs.length; k++) {
    const ballID = opponentBallIDs[k];
    if (!isPathBlocked(endStates[ballID], cueballPos, endStates)) {
      return false;
    }
  }
  return true;
}


function getCommandForBreakingCluster() {
  // return a command that shoots at table center 
  return { aimx: 0, aimy: 0 };
}

async function getCallShot() {

  // adopt special handler if there is a match
  const specialCmd1 = await checkEndGame1();
  if (specialCmd1) return specialCmd1;  

  // place holder for best command and highest probability
  let bestCommand = {prob: -1};

  // new constant representing table center
  const tableCenter = {x: 0, y: 0};
  const legalBallIDs = world.CandidateBallList[MyID];
  for (let k = 0 ; k &lt;= legalBallIDs.length-1 ; k=k+1 ) {
    const ballID = legalBallIDs[k];
    const isBlocked = isPathBlocked(Balls[ballID], Balls[0]);
    if (isBlocked) continue;

    for (let pocketID = 0; pocketID &lt;= 5 ; pocketID = pocketID + 1 ) {
      console.log("\nballID " + ballID + " pocketID " + pocketID);
      const aimPoint = getAimPosition(Balls[ballID], Pockets[pocketID]);

      const cutAngle = getCutAngle(Pockets[pocketID], aimPoint, Balls[0]);
      if (Math.abs(cutAngle) > 90) continue ;

      // iterate through strength values of 20/40/60/80
      for (let s = 20; s &lt;= 80; s = s + 20) {
        const cmd = { aimx: aimPoint.x, aimy: aimPoint.y, strength: s, targetBallID: ballID, targetPocketID: pocketID };
        
        const endStates = await calculateEndState(cmd);
        const cueballPosition = endStates[0];

        cmd.prob = await calculateProbability(cmd);
        cmd.distance = dist2(tableCenter, cueballPosition);
        cmd.minAngle = getMinCutAngle(endStates);
        console.log("Strength " + s + " prob " + cmd.prob + " cue ball " + cueballPosition.x + " " + cueballPosition.y);
        // new method to update best command 
        if (cmd.prob > 70 &amp;&amp; bestCommand.prob > 70) {
          // both commands are good enough for probability, 
          // so compare their cue ball end position
          if (cmd.minAngle &lt; bestCommand.minAngle) {
              bestCommand = cmd; 
          }
        } else {
          // simply choose the one with higher probability
          if (cmd.prob > bestCommand.prob) {
              bestCommand = cmd; 
          }
        }
      }
    }
  }

  // new behavior when we don't have a good shot
  if (bestCommand.prob >= 0 &amp;&amp; bestCommand.prob &lt; 50) {
    const targetPosOld = Balls[bestCommand.targetBallID];
    for (let s=2; s&lt;40; s=s+1) {
      console.log("trying strength " + s);
      bestCommand.strength = s;
      const endStates = await calculateEndState(bestCommand);
      const targetPosNew = endStates[bestCommand.targetBallID];
      if (targetPosOld.x != targetPosNew.x || targetPosOld.y != targetPosNew.y) {
        break;
      }
    }

    // new code added for lesson 20

    // check if end position of cue ball is blocked from all opponent balls
    const endStates = await calculateEndState(bestCommand);
    if (!allOpponentBallsBlocked(endStates)) {
      // return a command to break clusters if any
      const clusterCommand = getCommandForBreakingCluster();
      if (clusterCommand != null) return clusterCommand;

    }
    // end of new code

  } else if (bestCommand.prob == -1) {
    // search for best kick shot command with highest success probability

    // setup the bestCommand as negative probability so it will be reassigned later
    bestCommand = {prob: -1};
    
    // iterate through all legal ball IDs
    for (let k = 0 ; k &lt;= legalBallIDs.length-1 ; k=k+1 ) {
      const ballID = legalBallIDs[k];

      // iterate through all bottom pockets
      for (let pocketID = 3; pocketID &lt;= 5 ; pocketID = pocketID + 1 ) {
        const contactPoint = getAimPosition(Balls[ballID], Pockets[pocketID]);   
        const mirrorPoint = {x: contactPoint.x, y: 2 * Boundaries.TOP_Y - contactPoint.y};

        // search for the optimal adjustment amount 
        let direction = 1;
        if (Balls[ballID].x > Balls[0].x) {
          direction = -1;
        }
        
        for (let adjustX = 0; adjustX &lt; 50; adjustX = adjustX + 1) { 
          const cmd = {aimx: mirrorPoint.x + adjustX * direction, aimy: mirrorPoint.y, strength: 45, targetBallID: ballID, targetPocketID: pocketID};    
          cmd.prob = await calculateProbability(cmd); 
          console.log("ball " + ballID + " pocket " + pocketID + " adjustX " + (adjustX * direction) + ": prob " + cmd.prob); 
          if (cmd.prob > bestCommand.prob) { 
            console.log("new best!");
            bestCommand = cmd; 
          } 
        }   
      }
    }      
  }

  // return the best command we found
  return bestCommand;
}    

function getBreakShot() {
  return { 
    aimx: 0, aimy: 0, strength: 80
  }; 
}          
      
  </cleancode>
</element>  


<element elementid="108" elementType="Coding" condition="TestFinishedAnyResultAimBall_2">
  <p>
    <b>Challenge:</b> now let's implement the getCommandForBreakingCluster function properly using the code below as a guidance.
  </p>
  <p>
    The basic idea is to examine each legbal ball left on table, and see if any other ball is too close to it (distance less than 1.5 ball diameters). If so, this is a ball cluster, and we return a shot command that shoot at the legal ball to break the cluster.
  </p>
  <code isHidden="false">
//TODO: search for balls that are too close
function getCommandForBreakingCluster() {

  const legalBallIDs = world.CandidateBallList[MyID];
  
  // walk through all legal balls
  for (let k = 0; k &lt; legalBallIDs.length; k++) {
    const ballID = legalBallIDs[k];

    // walk through each ball in the "Balls" array
    //h0::ballID2 should range from 1 to Balls.length-1::write "for (let ballID2 = 0; ballID2 &lt; Balls.length; ballID2++) {"
    for (let ballID2 = 1; ballID2 ?; ballID2 = ?) {
      // skip ballID2 if it is the same as ballID
      //h1::compare if ballID is equal to ballID2::write "ballID == ballID2"
      if ( ? ) continue;

      // skip ballID2 if that ball is in pocket already
      //h2::write "Balls[ballID2].inPocket"
      if ( ? ) continue;

      // calculate distance between the 2 balls
      //h3::use the "dist2" function and the Balls array
      ::const d = dist2(ballID, ballID2);
      ::const d = dist2(Ball[ballID], Ball[ballID2]);
      ::const d = dist2(Balls[ballID], Balls[ballID2]);
      const d = ?;

      // if the distance is less than 1.5 times of ball diameter
      //h4::compare d with 1.5 * BallDiameter::write "d &lt; 1.5*BallDiameter"
      if ( ? ) {
        // found a cluster, so simply shoot at the ball with ballID
        return { aimx: Balls[ballID].x, aimy: Balls[ballID].y };
      }
    }
  }
  // no cluster found, so return null
  return null;
}
//ENDTODO
  </code>   
  <cleancode>
function getCueBallPlacement() {
  const legalBallIDs = world.CandidateBallList[MyID];
  for (let k = 0; k &lt; legalBallIDs.length; k ++) {
    const ballID = legalBallIDs[k];
    const ballPos = Balls[ballID];
    for (let pocketID=0; pocketID &lt;= 5; pocketID ++) {
      const pocketPos = Pockets[pocketID];
      const isBlocked = isPathBlocked(ballPos, pocketPos);
      if ( !isBlocked ) {
          return extrapolatePoints(pocketPos, ballPos, 2 * BallDiameter);  
      }
    }
  }
}


/*
Purpose: 
  To check if the current ball placement on table matches 
  with the given scenario description.

Return value: 
  - empty list "[]" if not matching 
  - an array of ball IDs corresponding to each region
*/

function matchScenario(scenario) {

  // first check number of balls left on table
  let countOfBallsOnTable = 0;
  for (let ballID=0; ballID &lt; Balls.length; ballID ++) {
    const b = Balls[ballID];
    if (b.inPocket) continue;
    // add 1 to counter for balls left on table
    countOfBallsOnTable ++;
  }

  // if the number of balls is not equal to number of regions in the scenario, no match
  if (countOfBallsOnTable != scenario.length) return [];

  // keep track of ball ID of each ball matching with a region
  let matchedBallIDs = [];

  // go through each region in the scenario array 
  for (let k=0; k &lt; scenario.length; k++) {
    const r = scenario[k];
    
    // try to find a matching ball for this region
    let found = false;

    // go through all balls 
    for (let ballID=0; ballID &lt; Balls.length; ballID ++) {
      const b = Balls[ballID];
      // ignore a ball if it is already pocketed
      if (b.inPocket) continue;

      // check ball color and coordinate against region definition
      if (b.colorType != r.colorType) continue;
      if (Math.abs(b.x - r.x) > r.width/2) continue;
      if (Math.abs(b.y - r.y) > r.height/2) continue;

      // this ball has found a matching region
      found = true;

      // record the ballID matching this region
      matchedBallIDs.push(ballID);

      // no need to search any more
      break;
    }

    // if a region doesn't have a matching ball, then not a match
    if (!found) return [];
  }

  // we have a match, and here are the ballIDs for each region
  return matchedBallIDs;
}

async function checkEndGame1() {
  const scenario = [
    {colorType: Pool.WHITE, x: -800, y: -300, width: 200, height: 150},
    {colorType: Pool.BLACK, x: 680, y: 0, width: 200, height: 200},
    {colorType: OpponentColorType, x: 125, y: 150, width: 400, height: 200},
  ];
  
  const matchedBallIDs = matchScenario(scenario);
  if (matchedBallIDs.length == 0) return null;
  
  const targetPoint = extrapolatePoints(Balls[matchedBallIDs[2]], Balls[1], BallDiameter);
  let bestCommand = {distance: 10000};
  for (let y = (Balls[0].y + Balls[1].y)/2; y &lt; Balls[1].y; y = y + 3) {
    for (let s = 18; s &lt; 29; s ++) {
      console.log("Checking y " + y + " strength " + s);

      // calculate cue ball end position given the current aim point and strength
      const cmd = {aimx: Boundaries.RIGHT_X - BallDiameter/2, aimy: y, strength: s};
      const endStates = await calculateEndState(cmd);
      cmd.distance = dist2(endStates[0], targetPoint);

      // check movement of black ball 
      const blackBallMovement = dist2(Balls[1], endStates[1]);

      // if cue ball's end position is closer to optimal point, update bestCommand
      if (cmd.distance &lt; bestCommand.distance &amp;&amp; blackBallMovement > 0) {
        console.log("new best " + cmd.distance);
        bestCommand = cmd;
      }
    }
  }
  
  return bestCommand;
}

// given endStates, what's the minimum cut angel for any ball-pocket combination
function getMinCutAngle(endStates) {
  let minAngle = 361;
  const legalBallIDs = world.CandidateBallList[MyID]; 
  for (let k = 0; k &lt; legalBallIDs.length; k ++) { 
    const ballID = legalBallIDs[k]; 
    const targetBallPos = endStates[ballID]; 
    for (let pocketID=0; pocketID &lt;= 5; pocketID ++) { 
      const cueballPos = endStates[0];
      const pocketPos = Pockets[pocketID]; 
      const aimPoint = getAimPosition(targetBallPos, pocketPos); 
      const angle = Math.abs(getCutAngle(pocketPos, aimPoint, cueballPos));

      if (angle &lt; minAngle) {
        minAngle = angle;
      }
    }
  }
  return minAngle;
}



function allOpponentBallsBlocked(endStates) {
  const opponentBallIDs = world.CandidateBallList[1 - MyID];
  const cueballPos = endStates[0];
  for (let k = 0; k &lt; opponentBallIDs.length; k++) {
    const ballID = opponentBallIDs[k];
    if (!isPathBlocked(endStates[ballID], cueballPos, endStates)) {
      return false;
    }
  }
  return true;
}


//search for any ball cluster and break it
function getCommandForBreakingCluster() {
  const legalBallIDs = world.CandidateBallList[MyID];
  
  // walk through all legal balls
  for (let k = 0; k &lt; legalBallIDs.length; k++) {
    const ballID = legalBallIDs[k];

    // walk through each ball in the "Balls" array
    for (let ballID2 = 0; ballID2 &lt; Balls.length; ballID2++) {
      // skip ballID2 if it is the same as ballID
      if ( ballID == ballID2 ) continue;

      // skip ballID2 if that ball is in pocket already
      if (Balls[ballID2].inPocket) continue;

      // calculate distance between the 2 balls
      const d = dist2(Balls[ballID], Balls[ballID2]);

      // if the distance is less than 1.5 times of ball diameter
      if ( d &lt; 1.5*BallDiameter ) {
        // found a cluster, so simply shoot at the ball with ballID
        return { aimx: Balls[ballID].x, aimy: Balls[ballID].y };
      }
    }
  }
  // no cluster found, so return null
  return null;
}

async function getCallShot() {

  // adopt special handler if there is a match
  const specialCmd1 = await checkEndGame1();
  if (specialCmd1) return specialCmd1;  

  // place holder for best command and highest probability
  let bestCommand = {prob: -1};

  // new constant representing table center
  const tableCenter = {x: 0, y: 0};
  const legalBallIDs = world.CandidateBallList[MyID];
  for (let k = 0 ; k &lt;= legalBallIDs.length-1 ; k=k+1 ) {
    const ballID = legalBallIDs[k];
    const isBlocked = isPathBlocked(Balls[ballID], Balls[0]);
    if (isBlocked) continue;

    for (let pocketID = 0; pocketID &lt;= 5 ; pocketID = pocketID + 1 ) {
      console.log("\nballID " + ballID + " pocketID " + pocketID);
      const aimPoint = getAimPosition(Balls[ballID], Pockets[pocketID]);

      const cutAngle = getCutAngle(Pockets[pocketID], aimPoint, Balls[0]);
      if (Math.abs(cutAngle) > 90) continue ;

      // iterate through strength values of 20/40/60/80
      for (let s = 20; s &lt;= 80; s = s + 20) {
        const cmd = { aimx: aimPoint.x, aimy: aimPoint.y, strength: s, targetBallID: ballID, targetPocketID: pocketID };
        
        const endStates = await calculateEndState(cmd);
        const cueballPosition = endStates[0];

        cmd.prob = await calculateProbability(cmd);
        cmd.distance = dist2(tableCenter, cueballPosition);
        cmd.minAngle = getMinCutAngle(endStates);
        console.log("Strength " + s + " prob " + cmd.prob + " cue ball " + cueballPosition.x + " " + cueballPosition.y);
        // new method to update best command 
        if (cmd.prob > 70 &amp;&amp; bestCommand.prob > 70) {
          // both commands are good enough for probability, 
          // so compare their cue ball end position
          if (cmd.minAngle &lt; bestCommand.minAngle) {
              bestCommand = cmd; 
          }
        } else {
          // simply choose the one with higher probability
          if (cmd.prob > bestCommand.prob) {
              bestCommand = cmd; 
          }
        }
      }
    }
  }

  // new behavior when we don't have a good shot
  if (bestCommand.prob >= 0 &amp;&amp; bestCommand.prob &lt; 50) {
    const targetPosOld = Balls[bestCommand.targetBallID];
    for (let s=2; s&lt;40; s=s+1) {
      console.log("trying strength " + s);
      bestCommand.strength = s;
      const endStates = await calculateEndState(bestCommand);
      const targetPosNew = endStates[bestCommand.targetBallID];
      if (targetPosOld.x != targetPosNew.x || targetPosOld.y != targetPosNew.y) {
        break;
      }
    }

    // new code added for lesson 20

    // check if end position of cue ball is blocked from all opponent balls
    const endStates = await calculateEndState(bestCommand);
    if (!allOpponentBallsBlocked(endStates)) {
      // return a command to break clusters if any
      const clusterCommand = getCommandForBreakingCluster();
      if (clusterCommand != null) return clusterCommand;

    }
    // end of new code

  } else if (bestCommand.prob == -1) {
    // search for best kick shot command with highest success probability

    // setup the bestCommand as negative probability so it will be reassigned later
    bestCommand = {prob: -1};
    
    // iterate through all legal ball IDs
    for (let k = 0 ; k &lt;= legalBallIDs.length-1 ; k=k+1 ) {
      const ballID = legalBallIDs[k];

      // iterate through all bottom pockets
      for (let pocketID = 3; pocketID &lt;= 5 ; pocketID = pocketID + 1 ) {
        const contactPoint = getAimPosition(Balls[ballID], Pockets[pocketID]);   
        const mirrorPoint = {x: contactPoint.x, y: 2 * Boundaries.TOP_Y - contactPoint.y};

        // search for the optimal adjustment amount 
        let direction = 1;
        if (Balls[ballID].x > Balls[0].x) {
          direction = -1;
        }
        
        for (let adjustX = 0; adjustX &lt; 50; adjustX = adjustX + 1) { 
          const cmd = {aimx: mirrorPoint.x + adjustX * direction, aimy: mirrorPoint.y, strength: 45, targetBallID: ballID, targetPocketID: pocketID};    
          cmd.prob = await calculateProbability(cmd); 
          console.log("ball " + ballID + " pocket " + pocketID + " adjustX " + (adjustX * direction) + ": prob " + cmd.prob); 
          if (cmd.prob > bestCommand.prob) { 
            console.log("new best!");
            bestCommand = cmd; 
          } 
        }   
      }
    }      
  }

  // return the best command we found
  return bestCommand;
}    

function getBreakShot() {
  return { 
    aimx: 0, aimy: 0, strength: 80
  }; 
}          
         
  </cleancode> 
</element>  



<element elementid="200" elementType="Conclusion">
  <p>Well done!</p>
  <p><b>Summary:</b> you have just improved your getCallShot function so that when the safety shot is not going to block the cue ball from all opponent balls, you would simply break a ball cluster of yours. 
  </p>
  <p>
    <b>Open Directions:</b> there can be many other approaches to improve your situation. Below are some ideas for you to consider:
  </p>
  <p>
    <ul>
      <li>
        <b>Moving your target ball to a better position:</b> although you don't have a high probability shot to pocket your target ball, you can still try to move it closer to the mouth of a pocket. The key here is to adjust your shot strength so that even if your target ball is not pocketed, it stops at a point close to the pocket mouth.
      </li>
      <li>
        <b>Ruining an opponent ball:</b> when the default safety shot is not working, very often that's because one or two pockets are blocked by opponent balls. So you can also try to use your ball to kick the opponent ball away from the pocket mouth, taking a better position itself.
      </li>
    </ul>
  </p>
  <p>
    If you want to discuss any implementation or new idea with others, feel free to discuss in our forum.
  </p>
</element>
    

<!--
  function getCueBallPlacement() {
  const legalBallIDs = world.CandidateBallList[MyID];
  for (let k = 0; k < legalBallIDs.length; k++) {
    const ballID = legalBallIDs[k];
    const ballPos = Balls[ballID];
    for (let pocketID = 0; pocketID <= 5; pocketID++) {
      const pocketPos = Pockets[pocketID];
      const isBlocked = isPathBlocked(ballPos, pocketPos);
      if (!isBlocked) {
        return extrapolatePoints(pocketPos, ballPos, 2 * BallDiameter);
      }
    }
  }
}


/*
Purpose: 
  To check if the current ball placement on table matches 
  with the given scenario description.

Return value: 
  - empty list "[]" if not matching 
  - an array of ball IDs corresponding to each region
*/

function matchScenario(scenario) {

  // first check number of balls left on table
  let countOfBallsOnTable = 0;
  for (let ballID = 0; ballID < Balls.length; ballID++) {
    const b = Balls[ballID];
    if (b.inPocket) continue;
    // add 1 to counter for balls left on table
    countOfBallsOnTable++;
  }

  // if the number of balls is not equal to number of regions in the scenario, no match
  if (countOfBallsOnTable != scenario.length) return [];

  // keep track of ball ID of each ball matching with a region
  let matchedBallIDs = [];

  // go through each region in the scenario array 
  for (let k = 0; k < scenario.length; k++) {
    const r = scenario[k];

    // try to find a matching ball for this region
    let found = false;

    // go through all balls 
    for (let ballID = 0; ballID < Balls.length; ballID++) {
      const b = Balls[ballID];
      // ignore a ball if it is already pocketed
      if (b.inPocket) continue;

      // check ball color and coordinate against region definition
      if (b.colorType != r.colorType) continue;
      if (Math.abs(b.x - r.x) > r.width / 2) continue;
      if (Math.abs(b.y - r.y) > r.height / 2) continue;

      // this ball has found a matching region
      found = true;

      // record the ballID matching this region
      matchedBallIDs.push(ballID);

      // no need to search any more
      break;
    }

    // if a region doesn't have a matching ball, then not a match
    if (!found) return [];
  }

  // we have a match, and here are the ballIDs for each region
  return matchedBallIDs;
}

function checkEndGame1() {
  const scenario = [{
      colorType: Pool.WHITE,
      x: -800,
      y: -300,
      width: 200,
      height: 150
    },
    {
      colorType: Pool.BLACK,
      x: 680,
      y: 0,
      width: 200,
      height: 200
    },
    {
      colorType: OpponentColorType,
      x: 125,
      y: 150,
      width: 400,
      height: 200
    },
  ];

  const matchedBallIDs = matchScenario(scenario);
  if (matchedBallIDs.length == 0) return null;
  return {
    aimx: 0,
    aimy: 0,
    strength: 50
  };
}

// given endStates, what's the minimum cut angel for any ball-pocket combination
function getMinCutAngle(endStates) {
  let minAngle = 361;
  const legalBallIDs = world.CandidateBallList[MyID];
  for (let k = 0; k < legalBallIDs.length; k++) {
    const ballID = legalBallIDs[k];
    const targetBallPos = endStates[ballID];
    for (let pocketID = 0; pocketID <= 5; pocketID++) {
      const cueballPos = endStates[0];
      const pocketPos = Pockets[pocketID];
      const aimPoint = getAimPosition(targetBallPos, pocketPos);
      const angle = Math.abs(getCutAngle(pocketPos, aimPoint, cueballPos));

      if (angle < minAngle) {
        minAngle = angle;
      }
    }
  }
  return minAngle;
}

function allOpponentBallsBlocked(endStates) {
  const opponentBallIDs = world.CandidateBallList[1 - MyID];
  const cueballPos = endStates[0];
  for (let k = 0; k < opponentBallIDs.length; k++) {
    const ballID = opponentBallIDs[k];
    if (!isPathBlocked(endStates[ballID], cueballPos, endStates)) {
      return false;
    }
  }
  return true;
}

function getCommandForBreakingCluster() {

  // search for balls that are too close
  const legalBallIDs = world.CandidateBallList[MyID];
  
  for (let k = 0; k < legalBallIDs.length; k++) {
    const ballID = legalBallIDs[k];

    for (let ballID2 = 0; ballID2 < Balls.length; ballID2++) {
      
      if (ballID2 == ballID) continue;
      if (ballID2 == 0 || ballID2 == 1) continue;

      if (!Balls[ballID]) {
        debugger;
      }
      if (!Balls[ballID2]) {
        debugger;
      }
      const d = dist2(Balls[ballID], Balls[ballID2]);
      if (d < BallDiameter * 1.5) {
        // found a cluster
        return {
          aimx: Balls[ballID].x,
          aimy: Balls[ballID].y
        };
      }
    }
  }

  return null;
}

async function getCallShot() {

  // new logic: if special handler returns a shot command, then use it
  const specialCmd1 = checkEndGame1();
  if (specialCmd1) return specialCmd1;

  // place holder for best command and highest probability
  let bestCommand = {
    prob: -1
  };

  // new constant representing table center
  const tableCenter = {
    x: 0,
    y: 0
  };
  const legalBallIDs = world.CandidateBallList[MyID];
  for (let k = 0; k <= legalBallIDs.length - 1; k = k + 1) {
    const ballID = legalBallIDs[k];
    const isBlocked = isPathBlocked(Balls[ballID], Balls[0]);
    if (isBlocked) continue;

    for (let pocketID = 0; pocketID <= 5; pocketID = pocketID + 1) {
      console.log("\nballID " + ballID + " pocketID " + pocketID);
      const aimPoint = getAimPosition(Balls[ballID], Pockets[pocketID]);

      const cutAngle = getCutAngle(Pockets[pocketID], aimPoint, Balls[0]);
      if (Math.abs(cutAngle) > 90) continue;

      // iterate through strength values of 20 to 80 at step of 10
      for (let s = 20; s <= 80; s = s + 10) {
        const cmd = {
          aimx: aimPoint.x,
          aimy: aimPoint.y,
          strength: s,
          targetBallID: ballID,
          targetPocketID: pocketID
        };

        const endStates = await calculateEndState(cmd);
        const cueballPosition = endStates[0];

        cmd.prob = await calculateProbability(cmd);
        cmd.distance = dist2(tableCenter, cueballPosition);
        cmd.minAngle = getMinCutAngle(endStates);
        console.log("Strength " + s + " prob " + cmd.prob + " cue ball " + cueballPosition.x + " " + cueballPosition.y);
        // new method to update best command 
        if (cmd.prob > 70 && bestCommand.prob > 70) {
          // both commands are good enough for probability, 
          // so compare their cue ball end position
          if (cmd.minAngle < bestCommand.minAngle) {
            bestCommand = cmd;
          }
        } else {
          // simply choose the one with higher probability
          if (cmd.prob > bestCommand.prob) {
            bestCommand = cmd;
          }
        }
      }
    }
  }

  // new behavior when we don't have a good shot
  if (bestCommand.prob >= 0 && bestCommand.prob < 50) {

    const targetPosOld = Balls[bestCommand.targetBallID];
    for (let s = 2; s < 40; s = s + 1) {
      console.log("trying strength " + s);
      bestCommand.strength = s;
      const endStates = await calculateEndState(bestCommand);
      const targetPosNew = endStates[bestCommand.targetBallID];
      if (targetPosOld.x != targetPosNew.x || targetPosOld.y != targetPosNew.y) {
        break;
      }
    }

    // check if end position of cue ball is blocked from all opponent balls
    const endStates = await calculateEndState(bestCommand);
    if (!allOpponentBallsBlocked(endStates)) {
      const clusterCommand = getCommandForBreakingCluster();
      if (clusterCommand != null) return clusterCommand;

    }




  } else if (bestCommand.prob == -1) {
    // search for best kick shot command with highest success probability

    // setup the bestCommand as negative probability so it will be reassigned later
    bestCommand = {
      prob: -1
    };

    // iterate through all legal ball IDs
    for (let k = 0; k <= legalBallIDs.length - 1; k = k + 1) {
      const ballID = legalBallIDs[k];

      // iterate through all bottom pockets
      for (let pocketID = 3; pocketID <= 5; pocketID = pocketID + 1) {
        const contactPoint = getAimPosition(Balls[ballID], Pockets[pocketID]);
        const mirrorPoint = {
          x: contactPoint.x,
          y: 2 * Boundaries.TOP_Y - contactPoint.y
        };

        // search for the optimal adjustment amount 
        let direction = 1;
        if (Balls[ballID].x > Balls[0].x) {
          direction = -1;
        }

        for (let adjustX = 0; adjustX < 50; adjustX = adjustX + 1) {
          const cmd = {
            aimx: mirrorPoint.x + adjustX * direction,
            aimy: mirrorPoint.y,
            strength: 45,
            targetBallID: ballID,
            targetPocketID: pocketID
          };
          cmd.prob = await calculateProbability(cmd);
          console.log("ball " + ballID + " pocket " + pocketID + " adjustX " + (adjustX * direction) + ": prob " + cmd.prob);
          if (cmd.prob > bestCommand.prob) {
            console.log("new best!");
            bestCommand = cmd;
          }
        }
      }
    }
  }

  // return the best command we found
  return bestCommand;
}

function getBreakShot() {
  return {
    aimx: 0,
    aimy: 0,
    strength: 80
  };
}
-->