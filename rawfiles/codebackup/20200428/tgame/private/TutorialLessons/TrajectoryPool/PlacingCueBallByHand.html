<element elementid="099" elementType="InitialCode">
  <cleancode>
async function getCallShot() {
  // place holder for best command and highest probability
  let bestCommand = null;
  let highestProb = -1;
  const legalBallIDs = world.CandidateBallList[MyID];

  for (let k = 0; k &lt;= legalBallIDs.length - 1; k = k + 1) {
    const ballID = legalBallIDs[k];

    for (let pocketID = 0; pocketID &lt;= 5; pocketID = pocketID + 1) {
      const aimPoint = getAimPosition(Balls[ballID], Pockets[pocketID]);
      const cmd = { 
        aimx: aimPoint.x, 
        aimy: aimPoint.y, 
        strength: 30, 
        targetBallID: ballID, 
        targetPocketID: pocketID 
      };
      const prob = await calculateProbability(cmd);

      if (prob > highestProb) {
        bestCommand = cmd;
        highestProb = prob;
      }
    } // end of for loop "pocketID"
  } // end of for loop "k"

  // return the best command we found
  return bestCommand;
}

function getBreakShot() {
  return {
    aimx: 0,
    aimy: 0,
    strength: 80
  };
}           
  </cleancode>
</element>

<element elementid="100" elementType="Info">
    <p>
      In the next two tutorials, we'll focus on the third and final key function of your bot. This function, <b class="variablenamebold">getCueBallPlacement</b>, will allow your bot to specify the placement of the cue ball when your opponent has committed a foul.
    </p>
    <p>
      You can find discussions about this lesson <a href="https://forum.tgame.ai/t/placing-cue-ball-by-hand/44" target="_blank">here in our forum</a>.
    </p>
</element>

<element elementid="101" elementType="Coding"  condition="TestFinishedAnyResult">
    <p>
      The <b class="variablenamebold">getCueBallPlacement</b> function must return an object with x and y properties. This function can be as simple as returning an object representing the table center: "return {x: 0, y: 0}". 
      </p>
      <p>
      <b>Please go ahead and add this new function now to your robot code</b>. It should be very similar to the <span class="variablenamebold">getBreakShot</span> function, and please keep the existing getCallShot and getBreakShot functions unchanged.
    </p>  
    <p>
      Click <b>Test</b> when you are finished. In the test script for this lesson, we ask your bot to place the cue ball on the table and then take a call shot. Your bot should most likely choose to shoot ball 3 towards pocket 1.
    </p>
    <code isHidden="false">
//TODO: add a new function getCueBallPlacement
//h0::declare the function getCueBallPlacement::write 'function getCueBallPlacement() {'
function ? {
  //h1::return an object with both x and y properties as 0::write 'return {x: 0, y: 0};'
  return ?;
}
//ENDTODO
  </code>
  <cleancode>
function getCueBallPlacement() {
  return {
    x: 0,
    y: 0
  };
}
    
async function getCallShot() {
  // place holder for best command and highest probability
  let bestCommand = null;
  let highestProb = -1;
  const legalBallIDs = world.CandidateBallList[MyID];

  for (let k = 0; k &lt;= legalBallIDs.length - 1; k = k + 1) {
    const ballID = legalBallIDs[k];

    for (let pocketID = 0; pocketID &lt;= 5; pocketID = pocketID + 1) {
      const aimPoint = getAimPosition(Balls[ballID], Pockets[pocketID]);
      const cmd = { 
        aimx: aimPoint.x, 
        aimy: aimPoint.y, 
        strength: 30, 
        targetBallID: ballID, 
        targetPocketID: pocketID 
      };
      const prob = await calculateProbability(cmd);

      if (prob > highestProb) {
        bestCommand = cmd;
        highestProb = prob;
      }
    } // end of for loop "pocketID"
  } // end of for loop "k"

  // return the best command we found
  return bestCommand;
}

function getBreakShot() {
  return {
    aimx: 0,
    aimy: 0,
    strength: 80
  };
}   
  </cleancode>
</element>
      
      
<!-- <element elementid="101" elementType="Coding"  condition="TestFinishedAnyResult">
  <p>
    In the test script for this lesson, we first ask your robot to place the cue ball on the table (using its getCueBallPlacement function), then choose the best ball to shoot (using its getCallShot function). 
    </p>
    <p>
      Click <b>TEST</b> without changing the code now. Your robot would place the cue ball at table center (0, 0) in its getCueBallPlacement function. And then when the game engine asks your robot to make a call shot, your robot would choose to shoot ball 3 towards pocket 1 from the table center.
    </p>
</element> -->



<element elementid="102" elementType="Coding"  condition="TestPPPocketBall_2_In_5">
  <p>
    When your opponent has committed a foul, what is the best position to place the cue ball before you take the next shot? Your goal should be to <b>place the cue ball in such a position that your bot will have an "easy" shot next</b> (a shot with high probability of success).
  </p>
  <p>
    <b>Challenge:</b> in the robot code editor, <b> change the x and y values in your <span class="variablenamebold">getCueBallPlacement</span> function</b> such that your robot will choose to shoot ball 2 into pocket 5 (left bottom). Experiment by clicking on the table to move the aiming point around or dragging the cue ball in order to find a good spot. For a hint, the cue ball should be approximately on the same line as ball 2 and pocket 5.
  </p>
  <p>
    <img src="/images/ball2pocket5.jpg" style="width: 50%; height: auto; margin-left: 25%; vertical-align: top;"/>
  </p>
  <code isHidden="false">
//TODO: change x and y so that your robot will shoot ball 2 into pocket 5
function getCueBallPlacement() {
  //h0::ball 2 should be roughly in line with ball 2 and pocket 5
  ::return {x: -340, y: -50}
  ::return {x: -509, y: 144}
  ::return {x: -100, y: 238}
  return {x: ?, y: ?};
}
//ENDTODO
  </code>  
  <cleancode>
function getCueBallPlacement() {
  return {
    x: -509, 
    y: 144
  };
}

async function getCallShot() {
  // place holder for best command and highest probability
  let bestCommand = null;
  let highestProb = -1;
  const legalBallIDs = world.CandidateBallList[MyID];

  for (let k = 0; k &lt;= legalBallIDs.length - 1; k = k + 1) {
    const ballID = legalBallIDs[k];

    for (let pocketID = 0; pocketID &lt;= 5; pocketID = pocketID + 1) {
      const aimPoint = getAimPosition(Balls[ballID], Pockets[pocketID]);
      const cmd = { 
        aimx: aimPoint.x, 
        aimy: aimPoint.y, 
        strength: 30, 
        targetBallID: ballID, 
        targetPocketID: pocketID 
      };
      const prob = await calculateProbability(cmd);

      if (prob > highestProb) {
        bestCommand = cmd;
        highestProb = prob;
      }
    } // end of for loop "pocketID"
  } // end of for loop "k"

  // return the best command we found
  return bestCommand;
}

function getBreakShot() {
  return {
    aimx: 0,
    aimy: 0,
    strength: 80
  };
}         
  </cleancode>      
</element>



<element elementid="103" elementType="Quiz" answerKey="B" answerReason="I will explain next.">
    <p>
      Instead of hardcoding a position for the cue ball, we can calculate the cue ball placement using the pocket and ball position as shown below. Essentially <b>we draw a line from the pocket center to the center of the target ball, and then extend that line further</b>. Placing the cue ball at any point on this extended line will give us a straight shot into the pocket.
    </p>
    <p>
      <img src="/images/cueballplacementline.jpg" style="width: 70%; height: auto; margin-left: 15%; vertical-align: top;"/>
    </p>
    <p>
      As you might have realized, if we place the cue ball on this line immediately touching ball 2, <b>it is exactly the aiming point returned by the <span class="variablenamebold">getAimPosition</span> helper function</b>. 
    </p>
    <p>
      <b>Quiz</b>: Do you think we can simply reuse the aiming point returned by <b class="variablenamebold">getAimPosition</b> and place the cue ball there? Think about it for a moment. Type <a href="#" onclick="ClickToSendChat(event, 'A')" class="inlinebutton"><b>A</b></a> for yes and <a href="#" onclick="ClickToSendChat(event, 'B')" class="inlinebutton"><b>B</b></a> for no. Hint: consider what happens when you calculate the call shot command.
    </p>
</element>
      
<element elementid="104" elementType="Info">
  <p>
    Perhaps you recognized that placing the cue ball exactly at the aim position would put the ball directly above the aim point. We can't tell the game engine "shoot the cue ball towards the point (200, 300)" when the cue ball is already at that point! The game engine would not know which direction to shoot towards. For this reason, <span class="variablename">getAimPosition</span> will not work.</p>
    
    <p>Instead, we have provided you another helper function called <b class="variablenamebold">extrapolatePoints</b>, which calculates a new point by first drawing a line from point1 to point2 and then extrapolating (extending) that line further by a given distance. For example, as shown below, you can calculate cue ball placement using the pocket position, the ball position, and a distance that is twice the <b class="variablenamebold">BallDiameter</b>:
  </p>
  <p>
    <img src="/images/cueballplacementline2.jpg" style="width: 70%; height: auto; margin-left: 15%; vertical-align: top;"/>
  </p>
  <p>
    Note that <b>the ordering of point1 and point2 is very important when you call <span class="variablenamebold">extrapolatePoints</span></b>, since we are drawing a line from point1 to point2 and extending the line beyond point2.
  </p>
</element>


<element elementid="106" elementType="Coding" condition="TestPPPocketBall_2_In_5_UsingExtrapolate">
  <p>
    <b>Challenge:</b> Change your <span class="variablename">getCueBallPlacement</span> function to call the <b class="variablenamebold">extrapolatePoints</b> function with with parameters (pocket position, ball position, and the distance of the returned point from target point) such that your robot will still choose to shoot ball 2 ("<span class="variablename">Balls[2]</span>") into pocket 5 ("<span class="variablename">Pockets[5]</span>"). Again, you can get the diameter of a ball using the pre-defined variable <span class="variablename">BallDiameter</span>.
  </p>
  <code isHidden="false">
//TODO: calculate x and y using extrapolatePoints  
function getCueBallPlacement() {
  //h0::the third parameter can be 2 * BallDiameter
  ::return extrapolatePoints(Balls[2], Pockets[5], 2 * BallDiameter);
  ::return extrapolatePoints(Pockets[5], Balls[2], 2 * BallDiameter);
  ::return extrapolatePoints(Pockets[5], Balls[2], 0);
  return extrapolatePoints(?, ?, ?);
}
//ENDTODO
  </code>
  <cleancode>
function getCueBallPlacement() {
  return extrapolatePoints(Pockets[5], Balls[2], 2 * BallDiameter);
}

async function getCallShot() {
  // place holder for best command and highest probability
  let bestCommand = null;
  let highestProb = -1;
  const legalBallIDs = world.CandidateBallList[MyID];

  for (let k = 0; k &lt;= legalBallIDs.length - 1; k = k + 1) {
    const ballID = legalBallIDs[k];

    for (let pocketID = 0; pocketID &lt;= 5; pocketID = pocketID + 1) {
      const aimPoint = getAimPosition(Balls[ballID], Pockets[pocketID]);
      const cmd = { 
        aimx: aimPoint.x, 
        aimy: aimPoint.y, 
        strength: 30, 
        targetBallID: ballID, 
        targetPocketID: pocketID 
      };
      const prob = await calculateProbability(cmd);

      if (prob > highestProb) {
        bestCommand = cmd;
        highestProb = prob;
      }
    } // end of for loop "pocketID"
  } // end of for loop "k"
  
  // return the best command we found
  return bestCommand;
}

function getBreakShot() {
  return {
    aimx: 0,
    aimy: 0,
    strength: 80
  };
}
  </cleancode>
</element>
  
<element elementid="180" elementType="Conclusion">
    <p>Tutorial completed!</p>
    <p>
      <b>Summary:</b> In this tutorial you have learned how to use the function <span class="variablenamebold">extrapolatePoints</span> to calculate optimal cue ball placement for a given ball-and-pocket combination. You have also created your own, new function <span class="variablenamebold">getCueBallPlacement</span> to place the cueball after a foul by your opponent. 
    </p>
    <p>
      <b>Exercise 1:</b> Change <span class="variablenamebold">getCueBallPlacement</span> such that your bot will shoot ball 3 into pocket 2 (top right). 
    </p>
    <p>
      <b>Exercise 2:</b> Can you change <span class="variablenamebold">getCueBallPlacement</span> such that your bot will shoot ball 3 towards pocket 5?</b>
    </p>    
    <p>
      <b>Exercise 3:</b> Can you change <span class="variablenamebold">getCueBallPlacement</span> such that your bot will shoot ball 2 into pocket 1?</b>
    </p> 
</element>


<!-- 


challenge 2: compare

// note that getCallShot is marked as "async" 
async function getCallShot() { 
  
  const aimPos3_0 = getAimPosition(world.Balls[3], world.Pockets[0]); 
  const shotCmd_3_0 = {aimx: aimPos3_0.x, aimy: aimPos3_0.y, strength: 1200, targetBallID: 3, targetPocketID: 0}; 
  const prob_3_0 = await calculateProbability(shotCmd_3_0); 
  
  //TODO: calculate probability of shooting ball 3 into pocket 1 
  const aimPos3_1 = getAimPosition(world.Balls[3], world.Pockets[1]); 
  const shotCmd_3_1 = {aimx: aimPos3_1.x, aimy: aimPos3_1.y, strength: 1200, targetBallID: 3, targetPocketID: 1}; 
  const prob_3_1 = await calculateProbability(shotCmd_3_1); 
  
  // return the command with higher probability 
  if (prob_3_0 >= prob_3_1) { 
    return shotCmd_3_0; 
  } else { 
    return shotCmd_3_1; 
  } 
}


function getBreakShot() {
  return { strength: 2000, aimx: 0, aimy: 0, cueballx: 0, cuebally: 0 }; 
}


challenge 3: 

async function getCallShot() { 
  // only look at ball 2 for now 
  const ballID = 2; 
  //place holder for best shot command 
  let bestShotCommand = null; 
  
  //TODO: conduct a grid search for best target pocket 
  let maxProb = -1; 
  for (let pocketID=0; pocketID < 6; pocketID++ ) { 
    const aimPos = getAimPosition(world.Balls[ballID], world.Pockets[pocketID]);
    const shotCmd = {aimx: aimPos.x, aimy: aimPos.y, strength: 1200, targetBallID: ballID, targetPocketID: pocketID};
    const prob = await calculateProbability(shotCmd);
    if ( prob > maxProb ) { 
      maxProb = prob; 
      bestShotCommand = shotCmd;
    } 
  } 
  
  // return the best shot with highest probability 
  return bestShotCommand;  
}

challenge 4:

// note that getCallShot is marked as async       
async function getCallShot() { 
  // get array of legal ball IDs 
  const legalBallIDs = world.CandidateBallList[MyID];
  //place holder for best shot command 
  let bestShotCommand = null; 
  
  //TODO: conduct a grid search for best target pocket 
  let maxProb = -1; 
  for (let i=0; i < legalBallIDs.length; i++ ) { 
    const ballID = legalBallIDs[i];
    for (let pocketID=0; pocketID < 6; pocketID++ ) { 
      const aimPos = getAimPosition(world.Balls[ballID], world.Pockets[pocketID]);
      const shotCmd = {aimx: aimPos.x, aimy: aimPos.y, strength: 1200, targetBallID: ballID, targetPocketID: pocketID};
      console.log("calculating prob b " + ballID + " p " + pocketID);
      const prob = await calculateProbability(shotCmd);
      if ( prob > maxProb ) { 
        maxProb = prob; 
        bestShotCommand = shotCmd;
      } 
    } 
  }  
  // return the best shot with highest probability 
  return bestShotCommand;  
}

function getBreakShot() { 
  return { strength: 3000, aimx: 0, aimy: 0, cueballx: 0, cuebally: 0 }; 
}

 -->